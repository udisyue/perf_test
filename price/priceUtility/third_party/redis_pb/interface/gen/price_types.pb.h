// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: price_types.proto

#ifndef PROTOBUF_price_5ftypes_2eproto__INCLUDED
#define PROTOBUF_price_5ftypes_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
// @@protoc_insertion_point(includes)

namespace price {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_price_5ftypes_2eproto();
void protobuf_AssignDesc_price_5ftypes_2eproto();
void protobuf_ShutdownFile_price_5ftypes_2eproto();

class UserInfo;
class CreditCard;
class GuaranteeAndDeposit;
class PromotionInfo;
class Tag;
class CancellationInfo;
class PriceItem;
class DailyPrice;
class BedType;
class BedGroup;
class ChargePrice;
class BoardInfo;
class ImageLink;
class ExtraCharge;
class RatePlan;
class ProductDesc;
class RoomDesc;
class ProductFilter;
class ProductFilterStat;
class PriceInfo;
class PersonHold;
class Product;
class Room;
class DetailOta;
class DetailHotel;
class ListOta;
class ListHotel;

enum RequestType {
  NORMAL = 1,
  CACHE = 2,
  CRAWLER = 3
};
bool RequestType_IsValid(int value);
const RequestType RequestType_MIN = NORMAL;
const RequestType RequestType_MAX = CRAWLER;
const int RequestType_ARRAYSIZE = RequestType_MAX + 1;

const ::google::protobuf::EnumDescriptor* RequestType_descriptor();
inline const ::std::string& RequestType_Name(RequestType value) {
  return ::google::protobuf::internal::NameOfEnum(
    RequestType_descriptor(), value);
}
inline bool RequestType_Parse(
    const ::std::string& name, RequestType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RequestType>(
    RequestType_descriptor(), name, value);
}
enum HotelStatus {
  FAILED = 1,
  SUCCESS_STOCK = 2,
  SUCCESS_SOLDOUT = 3
};
bool HotelStatus_IsValid(int value);
const HotelStatus HotelStatus_MIN = FAILED;
const HotelStatus HotelStatus_MAX = SUCCESS_SOLDOUT;
const int HotelStatus_ARRAYSIZE = HotelStatus_MAX + 1;

const ::google::protobuf::EnumDescriptor* HotelStatus_descriptor();
inline const ::std::string& HotelStatus_Name(HotelStatus value) {
  return ::google::protobuf::internal::NameOfEnum(
    HotelStatus_descriptor(), value);
}
inline bool HotelStatus_Parse(
    const ::std::string& name, HotelStatus* value) {
  return ::google::protobuf::internal::ParseNamedEnum<HotelStatus>(
    HotelStatus_descriptor(), name, value);
}
enum BookingStatus {
  BOOKING_FAIL = 1,
  BOOKING_SUCC = 2
};
bool BookingStatus_IsValid(int value);
const BookingStatus BookingStatus_MIN = BOOKING_FAIL;
const BookingStatus BookingStatus_MAX = BOOKING_SUCC;
const int BookingStatus_ARRAYSIZE = BookingStatus_MAX + 1;

const ::google::protobuf::EnumDescriptor* BookingStatus_descriptor();
inline const ::std::string& BookingStatus_Name(BookingStatus value) {
  return ::google::protobuf::internal::NameOfEnum(
    BookingStatus_descriptor(), value);
}
inline bool BookingStatus_Parse(
    const ::std::string& name, BookingStatus* value) {
  return ::google::protobuf::internal::ParseNamedEnum<BookingStatus>(
    BookingStatus_descriptor(), name, value);
}
enum PromotionType {
  SCORECARD = 1,
  CASHBACK = 2,
  GIFTCARD = 3,
  DISCOUNT = 4,
  CHINESESUPERIOR = 5,
  COUPON = 6,
  AVAIL_COUPON_LIST = 7,
  GIFT = 8,
  MOBILE_ONLY = 9,
  AVAIL_DISCOUNT_LIST = 10,
  OTA_SCORECARD = 101,
  OTA_CASHBACK = 102,
  OTA_GIFTCARD = 103,
  OTA_DISCOUNT = 104,
  OTA_CHINESESUPERIOR = 105,
  OTA_COUPON = 106,
  OTA_AVAIL_COUPON_LIST = 107,
  OTA_GIFT = 108,
  OTA_MOBILE_ONLY = 109,
  OTA_AVAIL_DISCOUNT_LIST = 110
};
bool PromotionType_IsValid(int value);
const PromotionType PromotionType_MIN = SCORECARD;
const PromotionType PromotionType_MAX = OTA_AVAIL_DISCOUNT_LIST;
const int PromotionType_ARRAYSIZE = PromotionType_MAX + 1;

const ::google::protobuf::EnumDescriptor* PromotionType_descriptor();
inline const ::std::string& PromotionType_Name(PromotionType value) {
  return ::google::protobuf::internal::NameOfEnum(
    PromotionType_descriptor(), value);
}
inline bool PromotionType_Parse(
    const ::std::string& name, PromotionType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PromotionType>(
    PromotionType_descriptor(), name, value);
}
enum TagType {
  C_BOOKINGRATE_TAG = 101,
  C_TOPIC_TAG = 102,
  C_ADCARD_TAG = 103,
  H_REVIEW_TAG = 201,
  H_PRICE_TAG = 202,
  H_ADCARD_TAG = 203,
  P_QUALITY_TAG = 301,
  P_PRICE_TAG = 302,
  P_ADCARD_TAG = 303,
  P_CONFIRM_TAG = 304
};
bool TagType_IsValid(int value);
const TagType TagType_MIN = C_BOOKINGRATE_TAG;
const TagType TagType_MAX = P_CONFIRM_TAG;
const int TagType_ARRAYSIZE = TagType_MAX + 1;

const ::google::protobuf::EnumDescriptor* TagType_descriptor();
inline const ::std::string& TagType_Name(TagType value) {
  return ::google::protobuf::internal::NameOfEnum(
    TagType_descriptor(), value);
}
inline bool TagType_Parse(
    const ::std::string& name, TagType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TagType>(
    TagType_descriptor(), name, value);
}
enum PayType {
  PRE_PAY = 1,
  CASH_PAY = 2
};
bool PayType_IsValid(int value);
const PayType PayType_MIN = PRE_PAY;
const PayType PayType_MAX = CASH_PAY;
const int PayType_ARRAYSIZE = PayType_MAX + 1;

const ::google::protobuf::EnumDescriptor* PayType_descriptor();
inline const ::std::string& PayType_Name(PayType value) {
  return ::google::protobuf::internal::NameOfEnum(
    PayType_descriptor(), value);
}
inline bool PayType_Parse(
    const ::std::string& name, PayType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PayType>(
    PayType_descriptor(), name, value);
}
enum ChargePriceMode {
  NO_SUCH_CHARGE = 0,
  CHARGE_IS_PER_STAY = 1,
  CHARGE_IS_PER_PERSON_PER_STAY = 2,
  CHARGE_IS_PER_NIGHT = 3,
  CHARGE_IS_PER_PERSON_AND_NIGHT_0 = 4,
  CHARGE_IS_A_PERCENTAGE = 5,
  CHARGE_IS_PER_PERSON_AND_NIGHT_1 = 6,
  CHARGE_IS_INCALCULABLE = 7,
  CHARGE_IS_INCALCULABLE_Croatia = 8
};
bool ChargePriceMode_IsValid(int value);
const ChargePriceMode ChargePriceMode_MIN = NO_SUCH_CHARGE;
const ChargePriceMode ChargePriceMode_MAX = CHARGE_IS_INCALCULABLE_Croatia;
const int ChargePriceMode_ARRAYSIZE = ChargePriceMode_MAX + 1;

const ::google::protobuf::EnumDescriptor* ChargePriceMode_descriptor();
inline const ::std::string& ChargePriceMode_Name(ChargePriceMode value) {
  return ::google::protobuf::internal::NameOfEnum(
    ChargePriceMode_descriptor(), value);
}
inline bool ChargePriceMode_Parse(
    const ::std::string& name, ChargePriceMode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ChargePriceMode>(
    ChargePriceMode_descriptor(), name, value);
}
enum ChargePriceType {
  UNKNOWN = 0,
  TAXANDSERVICEFEE = 1,
  EXTRAPERSONFEE = 2
};
bool ChargePriceType_IsValid(int value);
const ChargePriceType ChargePriceType_MIN = UNKNOWN;
const ChargePriceType ChargePriceType_MAX = EXTRAPERSONFEE;
const int ChargePriceType_ARRAYSIZE = ChargePriceType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ChargePriceType_descriptor();
inline const ::std::string& ChargePriceType_Name(ChargePriceType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ChargePriceType_descriptor(), value);
}
inline bool ChargePriceType_Parse(
    const ::std::string& name, ChargePriceType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ChargePriceType>(
    ChargePriceType_descriptor(), name, value);
}
// ===================================================================

class UserInfo : public ::google::protobuf::Message {
 public:
  UserInfo();
  virtual ~UserInfo();
  
  UserInfo(const UserInfo& from);
  
  inline UserInfo& operator=(const UserInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const UserInfo& default_instance();
  
  void Swap(UserInfo* other);
  
  // implements Message ----------------------------------------------
  
  UserInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UserInfo& from);
  void MergeFrom(const UserInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string user_ip = 1;
  inline bool has_user_ip() const;
  inline void clear_user_ip();
  static const int kUserIpFieldNumber = 1;
  inline const ::std::string& user_ip() const;
  inline void set_user_ip(const ::std::string& value);
  inline void set_user_ip(const char* value);
  inline void set_user_ip(const char* value, size_t size);
  inline ::std::string* mutable_user_ip();
  inline ::std::string* release_user_ip();
  
  // optional string session_id = 2;
  inline bool has_session_id() const;
  inline void clear_session_id();
  static const int kSessionIdFieldNumber = 2;
  inline const ::std::string& session_id() const;
  inline void set_session_id(const ::std::string& value);
  inline void set_session_id(const char* value);
  inline void set_session_id(const char* value, size_t size);
  inline ::std::string* mutable_session_id();
  inline ::std::string* release_session_id();
  
  // optional string cookie_id = 3;
  inline bool has_cookie_id() const;
  inline void clear_cookie_id();
  static const int kCookieIdFieldNumber = 3;
  inline const ::std::string& cookie_id() const;
  inline void set_cookie_id(const ::std::string& value);
  inline void set_cookie_id(const char* value);
  inline void set_cookie_id(const char* value, size_t size);
  inline ::std::string* mutable_cookie_id();
  inline ::std::string* release_cookie_id();
  
  // optional string user_agent = 4;
  inline bool has_user_agent() const;
  inline void clear_user_agent();
  static const int kUserAgentFieldNumber = 4;
  inline const ::std::string& user_agent() const;
  inline void set_user_agent(const ::std::string& value);
  inline void set_user_agent(const char* value);
  inline void set_user_agent(const char* value, size_t size);
  inline ::std::string* mutable_user_agent();
  inline ::std::string* release_user_agent();
  
  // optional int32 booking_channel = 5;
  inline bool has_booking_channel() const;
  inline void clear_booking_channel();
  static const int kBookingChannelFieldNumber = 5;
  inline ::google::protobuf::int32 booking_channel() const;
  inline void set_booking_channel(::google::protobuf::int32 value);
  
  // optional int32 order_from = 6;
  inline bool has_order_from() const;
  inline void clear_order_from();
  static const int kOrderFromFieldNumber = 6;
  inline ::google::protobuf::int32 order_from() const;
  inline void set_order_from(::google::protobuf::int32 value);
  
  // optional int32 customer_level = 7;
  inline bool has_customer_level() const;
  inline void clear_customer_level();
  static const int kCustomerLevelFieldNumber = 7;
  inline ::google::protobuf::int32 customer_level() const;
  inline void set_customer_level(::google::protobuf::int32 value);
  
  // repeated int32 activity_id_list = 8;
  inline int activity_id_list_size() const;
  inline void clear_activity_id_list();
  static const int kActivityIdListFieldNumber = 8;
  inline ::google::protobuf::int32 activity_id_list(int index) const;
  inline void set_activity_id_list(int index, ::google::protobuf::int32 value);
  inline void add_activity_id_list(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      activity_id_list() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_activity_id_list();
  
  // optional string user_id = 9;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 9;
  inline const ::std::string& user_id() const;
  inline void set_user_id(const ::std::string& value);
  inline void set_user_id(const char* value);
  inline void set_user_id(const char* value, size_t size);
  inline ::std::string* mutable_user_id();
  inline ::std::string* release_user_id();
  
  // optional string device_id = 10;
  inline bool has_device_id() const;
  inline void clear_device_id();
  static const int kDeviceIdFieldNumber = 10;
  inline const ::std::string& device_id() const;
  inline void set_device_id(const ::std::string& value);
  inline void set_device_id(const char* value);
  inline void set_device_id(const char* value, size_t size);
  inline ::std::string* mutable_device_id();
  inline ::std::string* release_device_id();
  
  // @@protoc_insertion_point(class_scope:price.UserInfo)
 private:
  inline void set_has_user_ip();
  inline void clear_has_user_ip();
  inline void set_has_session_id();
  inline void clear_has_session_id();
  inline void set_has_cookie_id();
  inline void clear_has_cookie_id();
  inline void set_has_user_agent();
  inline void clear_has_user_agent();
  inline void set_has_booking_channel();
  inline void clear_has_booking_channel();
  inline void set_has_order_from();
  inline void clear_has_order_from();
  inline void set_has_customer_level();
  inline void clear_has_customer_level();
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_device_id();
  inline void clear_has_device_id();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* user_ip_;
  ::std::string* session_id_;
  ::std::string* cookie_id_;
  ::std::string* user_agent_;
  ::google::protobuf::int32 booking_channel_;
  ::google::protobuf::int32 order_from_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > activity_id_list_;
  ::std::string* user_id_;
  ::std::string* device_id_;
  ::google::protobuf::int32 customer_level_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];
  
  friend void  protobuf_AddDesc_price_5ftypes_2eproto();
  friend void protobuf_AssignDesc_price_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_price_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static UserInfo* default_instance_;
};
// -------------------------------------------------------------------

class CreditCard : public ::google::protobuf::Message {
 public:
  CreditCard();
  virtual ~CreditCard();
  
  CreditCard(const CreditCard& from);
  
  inline CreditCard& operator=(const CreditCard& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const CreditCard& default_instance();
  
  void Swap(CreditCard* other);
  
  // implements Message ----------------------------------------------
  
  CreditCard* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CreditCard& from);
  void MergeFrom(const CreditCard& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string ota_bankcode = 1;
  inline bool has_ota_bankcode() const;
  inline void clear_ota_bankcode();
  static const int kOtaBankcodeFieldNumber = 1;
  inline const ::std::string& ota_bankcode() const;
  inline void set_ota_bankcode(const ::std::string& value);
  inline void set_ota_bankcode(const char* value);
  inline void set_ota_bankcode(const char* value, size_t size);
  inline ::std::string* mutable_ota_bankcode();
  inline ::std::string* release_ota_bankcode();
  
  // optional string elong_bankcode = 2;
  inline bool has_elong_bankcode() const;
  inline void clear_elong_bankcode();
  static const int kElongBankcodeFieldNumber = 2;
  inline const ::std::string& elong_bankcode() const;
  inline void set_elong_bankcode(const ::std::string& value);
  inline void set_elong_bankcode(const char* value);
  inline void set_elong_bankcode(const char* value, size_t size);
  inline ::std::string* mutable_elong_bankcode();
  inline ::std::string* release_elong_bankcode();
  
  // optional bytes card_desc = 3;
  inline bool has_card_desc() const;
  inline void clear_card_desc();
  static const int kCardDescFieldNumber = 3;
  inline const ::std::string& card_desc() const;
  inline void set_card_desc(const ::std::string& value);
  inline void set_card_desc(const char* value);
  inline void set_card_desc(const void* value, size_t size);
  inline ::std::string* mutable_card_desc();
  inline ::std::string* release_card_desc();
  
  // @@protoc_insertion_point(class_scope:price.CreditCard)
 private:
  inline void set_has_ota_bankcode();
  inline void clear_has_ota_bankcode();
  inline void set_has_elong_bankcode();
  inline void clear_has_elong_bankcode();
  inline void set_has_card_desc();
  inline void clear_has_card_desc();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* ota_bankcode_;
  ::std::string* elong_bankcode_;
  ::std::string* card_desc_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_price_5ftypes_2eproto();
  friend void protobuf_AssignDesc_price_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_price_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static CreditCard* default_instance_;
};
// -------------------------------------------------------------------

class GuaranteeAndDeposit : public ::google::protobuf::Message {
 public:
  GuaranteeAndDeposit();
  virtual ~GuaranteeAndDeposit();
  
  GuaranteeAndDeposit(const GuaranteeAndDeposit& from);
  
  inline GuaranteeAndDeposit& operator=(const GuaranteeAndDeposit& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GuaranteeAndDeposit& default_instance();
  
  void Swap(GuaranteeAndDeposit* other);
  
  // implements Message ----------------------------------------------
  
  GuaranteeAndDeposit* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GuaranteeAndDeposit& from);
  void MergeFrom(const GuaranteeAndDeposit& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional bool cc_required = 1 [default = false];
  inline bool has_cc_required() const;
  inline void clear_cc_required();
  static const int kCcRequiredFieldNumber = 1;
  inline bool cc_required() const;
  inline void set_cc_required(bool value);
  
  // optional bool cvc_required = 2 [default = false];
  inline bool has_cvc_required() const;
  inline void clear_cvc_required();
  static const int kCvcRequiredFieldNumber = 2;
  inline bool cvc_required() const;
  inline void set_cvc_required(bool value);
  
  // optional bool guarantee_required = 3 [default = false];
  inline bool has_guarantee_required() const;
  inline void clear_guarantee_required();
  static const int kGuaranteeRequiredFieldNumber = 3;
  inline bool guarantee_required() const;
  inline void set_guarantee_required(bool value);
  
  // optional .price.PriceItem guarantee_amount = 4;
  inline bool has_guarantee_amount() const;
  inline void clear_guarantee_amount();
  static const int kGuaranteeAmountFieldNumber = 4;
  inline const ::price::PriceItem& guarantee_amount() const;
  inline ::price::PriceItem* mutable_guarantee_amount();
  inline ::price::PriceItem* release_guarantee_amount();
  
  // optional bool deposit_required = 5 [default = false];
  inline bool has_deposit_required() const;
  inline void clear_deposit_required();
  static const int kDepositRequiredFieldNumber = 5;
  inline bool deposit_required() const;
  inline void set_deposit_required(bool value);
  
  // optional .price.PriceItem deposit_amount = 6;
  inline bool has_deposit_amount() const;
  inline void clear_deposit_amount();
  static const int kDepositAmountFieldNumber = 6;
  inline const ::price::PriceItem& deposit_amount() const;
  inline ::price::PriceItem* mutable_deposit_amount();
  inline ::price::PriceItem* release_deposit_amount();
  
  // @@protoc_insertion_point(class_scope:price.GuaranteeAndDeposit)
 private:
  inline void set_has_cc_required();
  inline void clear_has_cc_required();
  inline void set_has_cvc_required();
  inline void clear_has_cvc_required();
  inline void set_has_guarantee_required();
  inline void clear_has_guarantee_required();
  inline void set_has_guarantee_amount();
  inline void clear_has_guarantee_amount();
  inline void set_has_deposit_required();
  inline void clear_has_deposit_required();
  inline void set_has_deposit_amount();
  inline void clear_has_deposit_amount();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::price::PriceItem* guarantee_amount_;
  ::price::PriceItem* deposit_amount_;
  bool cc_required_;
  bool cvc_required_;
  bool guarantee_required_;
  bool deposit_required_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  friend void  protobuf_AddDesc_price_5ftypes_2eproto();
  friend void protobuf_AssignDesc_price_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_price_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static GuaranteeAndDeposit* default_instance_;
};
// -------------------------------------------------------------------

class PromotionInfo : public ::google::protobuf::Message {
 public:
  PromotionInfo();
  virtual ~PromotionInfo();
  
  PromotionInfo(const PromotionInfo& from);
  
  inline PromotionInfo& operator=(const PromotionInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const PromotionInfo& default_instance();
  
  void Swap(PromotionInfo* other);
  
  // implements Message ----------------------------------------------
  
  PromotionInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PromotionInfo& from);
  void MergeFrom(const PromotionInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional .price.PromotionType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline price::PromotionType type() const;
  inline void set_type(price::PromotionType value);
  
  // optional string value = 2;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 2;
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const char* value, size_t size);
  inline ::std::string* mutable_value();
  inline ::std::string* release_value();
  
  // @@protoc_insertion_point(class_scope:price.PromotionInfo)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_value();
  inline void clear_has_value();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* value_;
  int type_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_price_5ftypes_2eproto();
  friend void protobuf_AssignDesc_price_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_price_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static PromotionInfo* default_instance_;
};
// -------------------------------------------------------------------

class Tag : public ::google::protobuf::Message {
 public:
  Tag();
  virtual ~Tag();
  
  Tag(const Tag& from);
  
  inline Tag& operator=(const Tag& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Tag& default_instance();
  
  void Swap(Tag* other);
  
  // implements Message ----------------------------------------------
  
  Tag* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Tag& from);
  void MergeFrom(const Tag& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional .price.TagType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline price::TagType type() const;
  inline void set_type(price::TagType value);
  
  // optional string value = 2;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 2;
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const char* value, size_t size);
  inline ::std::string* mutable_value();
  inline ::std::string* release_value();
  
  // @@protoc_insertion_point(class_scope:price.Tag)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_value();
  inline void clear_has_value();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* value_;
  int type_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_price_5ftypes_2eproto();
  friend void protobuf_AssignDesc_price_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_price_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static Tag* default_instance_;
};
// -------------------------------------------------------------------

class CancellationInfo : public ::google::protobuf::Message {
 public:
  CancellationInfo();
  virtual ~CancellationInfo();
  
  CancellationInfo(const CancellationInfo& from);
  
  inline CancellationInfo& operator=(const CancellationInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const CancellationInfo& default_instance();
  
  void Swap(CancellationInfo* other);
  
  // implements Message ----------------------------------------------
  
  CancellationInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CancellationInfo& from);
  void MergeFrom(const CancellationInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string start_date = 1;
  inline bool has_start_date() const;
  inline void clear_start_date();
  static const int kStartDateFieldNumber = 1;
  inline const ::std::string& start_date() const;
  inline void set_start_date(const ::std::string& value);
  inline void set_start_date(const char* value);
  inline void set_start_date(const char* value, size_t size);
  inline ::std::string* mutable_start_date();
  inline ::std::string* release_start_date();
  
  // optional string local_start_date = 2;
  inline bool has_local_start_date() const;
  inline void clear_local_start_date();
  static const int kLocalStartDateFieldNumber = 2;
  inline const ::std::string& local_start_date() const;
  inline void set_local_start_date(const ::std::string& value);
  inline void set_local_start_date(const char* value);
  inline void set_local_start_date(const char* value, size_t size);
  inline ::std::string* mutable_local_start_date();
  inline ::std::string* release_local_start_date();
  
  // optional string end_date = 3;
  inline bool has_end_date() const;
  inline void clear_end_date();
  static const int kEndDateFieldNumber = 3;
  inline const ::std::string& end_date() const;
  inline void set_end_date(const ::std::string& value);
  inline void set_end_date(const char* value);
  inline void set_end_date(const char* value, size_t size);
  inline ::std::string* mutable_end_date();
  inline ::std::string* release_end_date();
  
  // optional string local_end_date = 4;
  inline bool has_local_end_date() const;
  inline void clear_local_end_date();
  static const int kLocalEndDateFieldNumber = 4;
  inline const ::std::string& local_end_date() const;
  inline void set_local_end_date(const ::std::string& value);
  inline void set_local_end_date(const char* value);
  inline void set_local_end_date(const char* value, size_t size);
  inline ::std::string* mutable_local_end_date();
  inline ::std::string* release_local_end_date();
  
  // optional string refundable = 5;
  inline bool has_refundable() const;
  inline void clear_refundable();
  static const int kRefundableFieldNumber = 5;
  inline const ::std::string& refundable() const;
  inline void set_refundable(const ::std::string& value);
  inline void set_refundable(const char* value);
  inline void set_refundable(const char* value, size_t size);
  inline ::std::string* mutable_refundable();
  inline ::std::string* release_refundable();
  
  // optional .price.PriceItem customer_price = 6;
  inline bool has_customer_price() const;
  inline void clear_customer_price();
  static const int kCustomerPriceFieldNumber = 6;
  inline const ::price::PriceItem& customer_price() const;
  inline ::price::PriceItem* mutable_customer_price();
  inline ::price::PriceItem* release_customer_price();
  
  // optional .price.PriceItem supplier_price = 7;
  inline bool has_supplier_price() const;
  inline void clear_supplier_price();
  static const int kSupplierPriceFieldNumber = 7;
  inline const ::price::PriceItem& supplier_price() const;
  inline ::price::PriceItem* mutable_supplier_price();
  inline ::price::PriceItem* release_supplier_price();
  
  // @@protoc_insertion_point(class_scope:price.CancellationInfo)
 private:
  inline void set_has_start_date();
  inline void clear_has_start_date();
  inline void set_has_local_start_date();
  inline void clear_has_local_start_date();
  inline void set_has_end_date();
  inline void clear_has_end_date();
  inline void set_has_local_end_date();
  inline void clear_has_local_end_date();
  inline void set_has_refundable();
  inline void clear_has_refundable();
  inline void set_has_customer_price();
  inline void clear_has_customer_price();
  inline void set_has_supplier_price();
  inline void clear_has_supplier_price();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* start_date_;
  ::std::string* local_start_date_;
  ::std::string* end_date_;
  ::std::string* local_end_date_;
  ::std::string* refundable_;
  ::price::PriceItem* customer_price_;
  ::price::PriceItem* supplier_price_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];
  
  friend void  protobuf_AddDesc_price_5ftypes_2eproto();
  friend void protobuf_AssignDesc_price_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_price_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static CancellationInfo* default_instance_;
};
// -------------------------------------------------------------------

class PriceItem : public ::google::protobuf::Message {
 public:
  PriceItem();
  virtual ~PriceItem();
  
  PriceItem(const PriceItem& from);
  
  inline PriceItem& operator=(const PriceItem& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const PriceItem& default_instance();
  
  void Swap(PriceItem* other);
  
  // implements Message ----------------------------------------------
  
  PriceItem* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PriceItem& from);
  void MergeFrom(const PriceItem& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int64 amount = 1;
  inline bool has_amount() const;
  inline void clear_amount();
  static const int kAmountFieldNumber = 1;
  inline ::google::protobuf::int64 amount() const;
  inline void set_amount(::google::protobuf::int64 value);
  
  // required string currency = 2 [default = "CNY"];
  inline bool has_currency() const;
  inline void clear_currency();
  static const int kCurrencyFieldNumber = 2;
  inline const ::std::string& currency() const;
  inline void set_currency(const ::std::string& value);
  inline void set_currency(const char* value);
  inline void set_currency(const char* value, size_t size);
  inline ::std::string* mutable_currency();
  inline ::std::string* release_currency();
  
  // optional double currency_rate = 3 [default = 1];
  inline bool has_currency_rate() const;
  inline void clear_currency_rate();
  static const int kCurrencyRateFieldNumber = 3;
  inline double currency_rate() const;
  inline void set_currency_rate(double value);
  
  // @@protoc_insertion_point(class_scope:price.PriceItem)
 private:
  inline void set_has_amount();
  inline void clear_has_amount();
  inline void set_has_currency();
  inline void clear_has_currency();
  inline void set_has_currency_rate();
  inline void clear_has_currency_rate();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int64 amount_;
  ::std::string* currency_;
  static const ::std::string _default_currency_;
  double currency_rate_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_price_5ftypes_2eproto();
  friend void protobuf_AssignDesc_price_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_price_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static PriceItem* default_instance_;
};
// -------------------------------------------------------------------

class DailyPrice : public ::google::protobuf::Message {
 public:
  DailyPrice();
  virtual ~DailyPrice();
  
  DailyPrice(const DailyPrice& from);
  
  inline DailyPrice& operator=(const DailyPrice& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const DailyPrice& default_instance();
  
  void Swap(DailyPrice* other);
  
  // implements Message ----------------------------------------------
  
  DailyPrice* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DailyPrice& from);
  void MergeFrom(const DailyPrice& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string date = 1;
  inline bool has_date() const;
  inline void clear_date();
  static const int kDateFieldNumber = 1;
  inline const ::std::string& date() const;
  inline void set_date(const ::std::string& value);
  inline void set_date(const char* value);
  inline void set_date(const char* value, size_t size);
  inline ::std::string* mutable_date();
  inline ::std::string* release_date();
  
  // optional .price.PriceItem price = 2;
  inline bool has_price() const;
  inline void clear_price();
  static const int kPriceFieldNumber = 2;
  inline const ::price::PriceItem& price() const;
  inline ::price::PriceItem* mutable_price();
  inline ::price::PriceItem* release_price();
  
  // @@protoc_insertion_point(class_scope:price.DailyPrice)
 private:
  inline void set_has_date();
  inline void clear_has_date();
  inline void set_has_price();
  inline void clear_has_price();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* date_;
  ::price::PriceItem* price_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_price_5ftypes_2eproto();
  friend void protobuf_AssignDesc_price_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_price_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static DailyPrice* default_instance_;
};
// -------------------------------------------------------------------

class BedType : public ::google::protobuf::Message {
 public:
  BedType();
  virtual ~BedType();
  
  BedType(const BedType& from);
  
  inline BedType& operator=(const BedType& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const BedType& default_instance();
  
  void Swap(BedType* other);
  
  // implements Message ----------------------------------------------
  
  BedType* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BedType& from);
  void MergeFrom(const BedType& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  
  // required bytes bed_name_cn = 2;
  inline bool has_bed_name_cn() const;
  inline void clear_bed_name_cn();
  static const int kBedNameCnFieldNumber = 2;
  inline const ::std::string& bed_name_cn() const;
  inline void set_bed_name_cn(const ::std::string& value);
  inline void set_bed_name_cn(const char* value);
  inline void set_bed_name_cn(const void* value, size_t size);
  inline ::std::string* mutable_bed_name_cn();
  inline ::std::string* release_bed_name_cn();
  
  // optional bytes bed_name_en = 3;
  inline bool has_bed_name_en() const;
  inline void clear_bed_name_en();
  static const int kBedNameEnFieldNumber = 3;
  inline const ::std::string& bed_name_en() const;
  inline void set_bed_name_en(const ::std::string& value);
  inline void set_bed_name_en(const char* value);
  inline void set_bed_name_en(const void* value, size_t size);
  inline ::std::string* mutable_bed_name_en();
  inline ::std::string* release_bed_name_en();
  
  // optional int32 num = 4;
  inline bool has_num() const;
  inline void clear_num();
  static const int kNumFieldNumber = 4;
  inline ::google::protobuf::int32 num() const;
  inline void set_num(::google::protobuf::int32 value);
  
  // optional bytes size = 5;
  inline bool has_size() const;
  inline void clear_size();
  static const int kSizeFieldNumber = 5;
  inline const ::std::string& size() const;
  inline void set_size(const ::std::string& value);
  inline void set_size(const char* value);
  inline void set_size(const void* value, size_t size);
  inline ::std::string* mutable_size();
  inline ::std::string* release_size();
  
  // optional bool is_ambiguous = 6 [default = true];
  inline bool has_is_ambiguous() const;
  inline void clear_is_ambiguous();
  static const int kIsAmbiguousFieldNumber = 6;
  inline bool is_ambiguous() const;
  inline void set_is_ambiguous(bool value);
  
  // @@protoc_insertion_point(class_scope:price.BedType)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_bed_name_cn();
  inline void clear_has_bed_name_cn();
  inline void set_has_bed_name_en();
  inline void clear_has_bed_name_en();
  inline void set_has_num();
  inline void clear_has_num();
  inline void set_has_size();
  inline void clear_has_size();
  inline void set_has_is_ambiguous();
  inline void clear_has_is_ambiguous();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* id_;
  ::std::string* bed_name_cn_;
  ::std::string* bed_name_en_;
  ::std::string* size_;
  ::google::protobuf::int32 num_;
  bool is_ambiguous_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  friend void  protobuf_AddDesc_price_5ftypes_2eproto();
  friend void protobuf_AssignDesc_price_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_price_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static BedType* default_instance_;
};
// -------------------------------------------------------------------

class BedGroup : public ::google::protobuf::Message {
 public:
  BedGroup();
  virtual ~BedGroup();
  
  BedGroup(const BedGroup& from);
  
  inline BedGroup& operator=(const BedGroup& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const BedGroup& default_instance();
  
  void Swap(BedGroup* other);
  
  // implements Message ----------------------------------------------
  
  BedGroup* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BedGroup& from);
  void MergeFrom(const BedGroup& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .price.BedType bed_type_list = 1;
  inline int bed_type_list_size() const;
  inline void clear_bed_type_list();
  static const int kBedTypeListFieldNumber = 1;
  inline const ::price::BedType& bed_type_list(int index) const;
  inline ::price::BedType* mutable_bed_type_list(int index);
  inline ::price::BedType* add_bed_type_list();
  inline const ::google::protobuf::RepeatedPtrField< ::price::BedType >&
      bed_type_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::price::BedType >*
      mutable_bed_type_list();
  
  // @@protoc_insertion_point(class_scope:price.BedGroup)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::price::BedType > bed_type_list_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_price_5ftypes_2eproto();
  friend void protobuf_AssignDesc_price_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_price_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static BedGroup* default_instance_;
};
// -------------------------------------------------------------------

class ChargePrice : public ::google::protobuf::Message {
 public:
  ChargePrice();
  virtual ~ChargePrice();
  
  ChargePrice(const ChargePrice& from);
  
  inline ChargePrice& operator=(const ChargePrice& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ChargePrice& default_instance();
  
  void Swap(ChargePrice* other);
  
  // implements Message ----------------------------------------------
  
  ChargePrice* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ChargePrice& from);
  void MergeFrom(const ChargePrice& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .price.PriceItem price = 1;
  inline bool has_price() const;
  inline void clear_price();
  static const int kPriceFieldNumber = 1;
  inline const ::price::PriceItem& price() const;
  inline ::price::PriceItem* mutable_price();
  inline ::price::PriceItem* release_price();
  
  // optional .price.PriceItem price_ori = 2;
  inline bool has_price_ori() const;
  inline void clear_price_ori();
  static const int kPriceOriFieldNumber = 2;
  inline const ::price::PriceItem& price_ori() const;
  inline ::price::PriceItem* mutable_price_ori();
  inline ::price::PriceItem* release_price_ori();
  
  // required bytes description = 3;
  inline bool has_description() const;
  inline void clear_description();
  static const int kDescriptionFieldNumber = 3;
  inline const ::std::string& description() const;
  inline void set_description(const ::std::string& value);
  inline void set_description(const char* value);
  inline void set_description(const void* value, size_t size);
  inline ::std::string* mutable_description();
  inline ::std::string* release_description();
  
  // optional .price.ChargePriceType type = 4 [default = UNKNOWN];
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 4;
  inline price::ChargePriceType type() const;
  inline void set_type(price::ChargePriceType value);
  
  // optional bool included = 5 [default = true];
  inline bool has_included() const;
  inline void clear_included();
  static const int kIncludedFieldNumber = 5;
  inline bool included() const;
  inline void set_included(bool value);
  
  // optional .price.ChargePriceMode charge_price_mode = 6;
  inline bool has_charge_price_mode() const;
  inline void clear_charge_price_mode();
  static const int kChargePriceModeFieldNumber = 6;
  inline price::ChargePriceMode charge_price_mode() const;
  inline void set_charge_price_mode(price::ChargePriceMode value);
  
  // optional string charge_amount = 7;
  inline bool has_charge_amount() const;
  inline void clear_charge_amount();
  static const int kChargeAmountFieldNumber = 7;
  inline const ::std::string& charge_amount() const;
  inline void set_charge_amount(const ::std::string& value);
  inline void set_charge_amount(const char* value);
  inline void set_charge_amount(const char* value, size_t size);
  inline ::std::string* mutable_charge_amount();
  inline ::std::string* release_charge_amount();
  
  // optional string charge_amount_currency = 8;
  inline bool has_charge_amount_currency() const;
  inline void clear_charge_amount_currency();
  static const int kChargeAmountCurrencyFieldNumber = 8;
  inline const ::std::string& charge_amount_currency() const;
  inline void set_charge_amount_currency(const ::std::string& value);
  inline void set_charge_amount_currency(const char* value);
  inline void set_charge_amount_currency(const char* value, size_t size);
  inline ::std::string* mutable_charge_amount_currency();
  inline ::std::string* release_charge_amount_currency();
  
  // @@protoc_insertion_point(class_scope:price.ChargePrice)
 private:
  inline void set_has_price();
  inline void clear_has_price();
  inline void set_has_price_ori();
  inline void clear_has_price_ori();
  inline void set_has_description();
  inline void clear_has_description();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_included();
  inline void clear_has_included();
  inline void set_has_charge_price_mode();
  inline void clear_has_charge_price_mode();
  inline void set_has_charge_amount();
  inline void clear_has_charge_amount();
  inline void set_has_charge_amount_currency();
  inline void clear_has_charge_amount_currency();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::price::PriceItem* price_;
  ::price::PriceItem* price_ori_;
  ::std::string* description_;
  int type_;
  bool included_;
  ::std::string* charge_amount_;
  ::std::string* charge_amount_currency_;
  int charge_price_mode_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];
  
  friend void  protobuf_AddDesc_price_5ftypes_2eproto();
  friend void protobuf_AssignDesc_price_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_price_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static ChargePrice* default_instance_;
};
// -------------------------------------------------------------------

class BoardInfo : public ::google::protobuf::Message {
 public:
  BoardInfo();
  virtual ~BoardInfo();
  
  BoardInfo(const BoardInfo& from);
  
  inline BoardInfo& operator=(const BoardInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const BoardInfo& default_instance();
  
  void Swap(BoardInfo* other);
  
  // implements Message ----------------------------------------------
  
  BoardInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BoardInfo& from);
  void MergeFrom(const BoardInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bool included = 1;
  inline bool has_included() const;
  inline void clear_included();
  static const int kIncludedFieldNumber = 1;
  inline bool included() const;
  inline void set_included(bool value);
  
  // optional bytes description = 2;
  inline bool has_description() const;
  inline void clear_description();
  static const int kDescriptionFieldNumber = 2;
  inline const ::std::string& description() const;
  inline void set_description(const ::std::string& value);
  inline void set_description(const char* value);
  inline void set_description(const void* value, size_t size);
  inline ::std::string* mutable_description();
  inline ::std::string* release_description();
  
  // optional int32 number = 3;
  inline bool has_number() const;
  inline void clear_number();
  static const int kNumberFieldNumber = 3;
  inline ::google::protobuf::int32 number() const;
  inline void set_number(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:price.BoardInfo)
 private:
  inline void set_has_included();
  inline void clear_has_included();
  inline void set_has_description();
  inline void clear_has_description();
  inline void set_has_number();
  inline void clear_has_number();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* description_;
  bool included_;
  ::google::protobuf::int32 number_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_price_5ftypes_2eproto();
  friend void protobuf_AssignDesc_price_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_price_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static BoardInfo* default_instance_;
};
// -------------------------------------------------------------------

class ImageLink : public ::google::protobuf::Message {
 public:
  ImageLink();
  virtual ~ImageLink();
  
  ImageLink(const ImageLink& from);
  
  inline ImageLink& operator=(const ImageLink& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ImageLink& default_instance();
  
  void Swap(ImageLink* other);
  
  // implements Message ----------------------------------------------
  
  ImageLink* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ImageLink& from);
  void MergeFrom(const ImageLink& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string image_id = 1;
  inline bool has_image_id() const;
  inline void clear_image_id();
  static const int kImageIdFieldNumber = 1;
  inline const ::std::string& image_id() const;
  inline void set_image_id(const ::std::string& value);
  inline void set_image_id(const char* value);
  inline void set_image_id(const char* value, size_t size);
  inline ::std::string* mutable_image_id();
  inline ::std::string* release_image_id();
  
  // optional string image_url = 2;
  inline bool has_image_url() const;
  inline void clear_image_url();
  static const int kImageUrlFieldNumber = 2;
  inline const ::std::string& image_url() const;
  inline void set_image_url(const ::std::string& value);
  inline void set_image_url(const char* value);
  inline void set_image_url(const char* value, size_t size);
  inline ::std::string* mutable_image_url();
  inline ::std::string* release_image_url();
  
  // @@protoc_insertion_point(class_scope:price.ImageLink)
 private:
  inline void set_has_image_id();
  inline void clear_has_image_id();
  inline void set_has_image_url();
  inline void clear_has_image_url();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* image_id_;
  ::std::string* image_url_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_price_5ftypes_2eproto();
  friend void protobuf_AssignDesc_price_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_price_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static ImageLink* default_instance_;
};
// -------------------------------------------------------------------

class ExtraCharge : public ::google::protobuf::Message {
 public:
  ExtraCharge();
  virtual ~ExtraCharge();
  
  ExtraCharge(const ExtraCharge& from);
  
  inline ExtraCharge& operator=(const ExtraCharge& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ExtraCharge& default_instance();
  
  void Swap(ExtraCharge* other);
  
  // implements Message ----------------------------------------------
  
  ExtraCharge* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ExtraCharge& from);
  void MergeFrom(const ExtraCharge& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .price.PriceItem total = 1;
  inline bool has_total() const;
  inline void clear_total();
  static const int kTotalFieldNumber = 1;
  inline const ::price::PriceItem& total() const;
  inline ::price::PriceItem* mutable_total();
  inline ::price::PriceItem* release_total();
  
  // required .price.PriceItem total_ori = 2;
  inline bool has_total_ori() const;
  inline void clear_total_ori();
  static const int kTotalOriFieldNumber = 2;
  inline const ::price::PriceItem& total_ori() const;
  inline ::price::PriceItem* mutable_total_ori();
  inline ::price::PriceItem* release_total_ori();
  
  // repeated .price.ChargePrice charge_price_list = 3;
  inline int charge_price_list_size() const;
  inline void clear_charge_price_list();
  static const int kChargePriceListFieldNumber = 3;
  inline const ::price::ChargePrice& charge_price_list(int index) const;
  inline ::price::ChargePrice* mutable_charge_price_list(int index);
  inline ::price::ChargePrice* add_charge_price_list();
  inline const ::google::protobuf::RepeatedPtrField< ::price::ChargePrice >&
      charge_price_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::price::ChargePrice >*
      mutable_charge_price_list();
  
  // @@protoc_insertion_point(class_scope:price.ExtraCharge)
 private:
  inline void set_has_total();
  inline void clear_has_total();
  inline void set_has_total_ori();
  inline void clear_has_total_ori();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::price::PriceItem* total_;
  ::price::PriceItem* total_ori_;
  ::google::protobuf::RepeatedPtrField< ::price::ChargePrice > charge_price_list_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_price_5ftypes_2eproto();
  friend void protobuf_AssignDesc_price_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_price_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static ExtraCharge* default_instance_;
};
// -------------------------------------------------------------------

class RatePlan : public ::google::protobuf::Message {
 public:
  RatePlan();
  virtual ~RatePlan();
  
  RatePlan(const RatePlan& from);
  
  inline RatePlan& operator=(const RatePlan& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RatePlan& default_instance();
  
  void Swap(RatePlan* other);
  
  // implements Message ----------------------------------------------
  
  RatePlan* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RatePlan& from);
  void MergeFrom(const RatePlan& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional bool is_instant_confirm = 1 [default = true];
  inline bool has_is_instant_confirm() const;
  inline void clear_is_instant_confirm();
  static const int kIsInstantConfirmFieldNumber = 1;
  inline bool is_instant_confirm() const;
  inline void set_is_instant_confirm(bool value);
  
  // optional bool breakfast_included = 2 [default = false];
  inline bool has_breakfast_included() const;
  inline void clear_breakfast_included();
  static const int kBreakfastIncludedFieldNumber = 2;
  inline bool breakfast_included() const;
  inline void set_breakfast_included(bool value);
  
  // optional bool halfboard_included = 3 [default = false];
  inline bool has_halfboard_included() const;
  inline void clear_halfboard_included();
  static const int kHalfboardIncludedFieldNumber = 3;
  inline bool halfboard_included() const;
  inline void set_halfboard_included(bool value);
  
  // optional bool fullboard_included = 4 [default = false];
  inline bool has_fullboard_included() const;
  inline void clear_fullboard_included();
  static const int kFullboardIncludedFieldNumber = 4;
  inline bool fullboard_included() const;
  inline void set_fullboard_included(bool value);
  
  // optional bool internet_included = 5 [default = false];
  inline bool has_internet_included() const;
  inline void clear_internet_included();
  static const int kInternetIncludedFieldNumber = 5;
  inline bool internet_included() const;
  inline void set_internet_included(bool value);
  
  // optional bool wifi_included = 6 [default = false];
  inline bool has_wifi_included() const;
  inline void clear_wifi_included();
  static const int kWifiIncludedFieldNumber = 6;
  inline bool wifi_included() const;
  inline void set_wifi_included(bool value);
  
  // optional int32 ota_promo_type = 7;
  inline bool has_ota_promo_type() const;
  inline void clear_ota_promo_type();
  static const int kOtaPromoTypeFieldNumber = 7;
  inline ::google::protobuf::int32 ota_promo_type() const;
  inline void set_ota_promo_type(::google::protobuf::int32 value);
  
  // optional .price.UserInfo user_info = 8;
  inline bool has_user_info() const;
  inline void clear_user_info();
  static const int kUserInfoFieldNumber = 8;
  inline const ::price::UserInfo& user_info() const;
  inline ::price::UserInfo* mutable_user_info();
  inline ::price::UserInfo* release_user_info();
  
  // optional .price.PayType pay_type = 9 [default = PRE_PAY];
  inline bool has_pay_type() const;
  inline void clear_pay_type();
  static const int kPayTypeFieldNumber = 9;
  inline price::PayType pay_type() const;
  inline void set_pay_type(price::PayType value);
  
  // optional .price.GuaranteeAndDeposit guarantee_and_deposit = 10;
  inline bool has_guarantee_and_deposit() const;
  inline void clear_guarantee_and_deposit();
  static const int kGuaranteeAndDepositFieldNumber = 10;
  inline const ::price::GuaranteeAndDeposit& guarantee_and_deposit() const;
  inline ::price::GuaranteeAndDeposit* mutable_guarantee_and_deposit();
  inline ::price::GuaranteeAndDeposit* release_guarantee_and_deposit();
  
  // repeated .price.PromotionInfo promotion_info_list = 11;
  inline int promotion_info_list_size() const;
  inline void clear_promotion_info_list();
  static const int kPromotionInfoListFieldNumber = 11;
  inline const ::price::PromotionInfo& promotion_info_list(int index) const;
  inline ::price::PromotionInfo* mutable_promotion_info_list(int index);
  inline ::price::PromotionInfo* add_promotion_info_list();
  inline const ::google::protobuf::RepeatedPtrField< ::price::PromotionInfo >&
      promotion_info_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::price::PromotionInfo >*
      mutable_promotion_info_list();
  
  // repeated .price.CancellationInfo cancellation_info_list = 12;
  inline int cancellation_info_list_size() const;
  inline void clear_cancellation_info_list();
  static const int kCancellationInfoListFieldNumber = 12;
  inline const ::price::CancellationInfo& cancellation_info_list(int index) const;
  inline ::price::CancellationInfo* mutable_cancellation_info_list(int index);
  inline ::price::CancellationInfo* add_cancellation_info_list();
  inline const ::google::protobuf::RepeatedPtrField< ::price::CancellationInfo >&
      cancellation_info_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::price::CancellationInfo >*
      mutable_cancellation_info_list();
  
  // repeated .price.CancellationInfo elong_cancellation_info_list = 13;
  inline int elong_cancellation_info_list_size() const;
  inline void clear_elong_cancellation_info_list();
  static const int kElongCancellationInfoListFieldNumber = 13;
  inline const ::price::CancellationInfo& elong_cancellation_info_list(int index) const;
  inline ::price::CancellationInfo* mutable_elong_cancellation_info_list(int index);
  inline ::price::CancellationInfo* add_elong_cancellation_info_list();
  inline const ::google::protobuf::RepeatedPtrField< ::price::CancellationInfo >&
      elong_cancellation_info_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::price::CancellationInfo >*
      mutable_elong_cancellation_info_list();
  
  // @@protoc_insertion_point(class_scope:price.RatePlan)
 private:
  inline void set_has_is_instant_confirm();
  inline void clear_has_is_instant_confirm();
  inline void set_has_breakfast_included();
  inline void clear_has_breakfast_included();
  inline void set_has_halfboard_included();
  inline void clear_has_halfboard_included();
  inline void set_has_fullboard_included();
  inline void clear_has_fullboard_included();
  inline void set_has_internet_included();
  inline void clear_has_internet_included();
  inline void set_has_wifi_included();
  inline void clear_has_wifi_included();
  inline void set_has_ota_promo_type();
  inline void clear_has_ota_promo_type();
  inline void set_has_user_info();
  inline void clear_has_user_info();
  inline void set_has_pay_type();
  inline void clear_has_pay_type();
  inline void set_has_guarantee_and_deposit();
  inline void clear_has_guarantee_and_deposit();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  bool is_instant_confirm_;
  bool breakfast_included_;
  bool halfboard_included_;
  bool fullboard_included_;
  bool internet_included_;
  bool wifi_included_;
  ::price::UserInfo* user_info_;
  ::google::protobuf::int32 ota_promo_type_;
  int pay_type_;
  ::price::GuaranteeAndDeposit* guarantee_and_deposit_;
  ::google::protobuf::RepeatedPtrField< ::price::PromotionInfo > promotion_info_list_;
  ::google::protobuf::RepeatedPtrField< ::price::CancellationInfo > cancellation_info_list_;
  ::google::protobuf::RepeatedPtrField< ::price::CancellationInfo > elong_cancellation_info_list_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(13 + 31) / 32];
  
  friend void  protobuf_AddDesc_price_5ftypes_2eproto();
  friend void protobuf_AssignDesc_price_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_price_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static RatePlan* default_instance_;
};
// -------------------------------------------------------------------

class ProductDesc : public ::google::protobuf::Message {
 public:
  ProductDesc();
  virtual ~ProductDesc();
  
  ProductDesc(const ProductDesc& from);
  
  inline ProductDesc& operator=(const ProductDesc& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ProductDesc& default_instance();
  
  void Swap(ProductDesc* other);
  
  // implements Message ----------------------------------------------
  
  ProductDesc* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ProductDesc& from);
  void MergeFrom(const ProductDesc& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .price.BoardInfo board_info_list = 1;
  inline int board_info_list_size() const;
  inline void clear_board_info_list();
  static const int kBoardInfoListFieldNumber = 1;
  inline const ::price::BoardInfo& board_info_list(int index) const;
  inline ::price::BoardInfo* mutable_board_info_list(int index);
  inline ::price::BoardInfo* add_board_info_list();
  inline const ::google::protobuf::RepeatedPtrField< ::price::BoardInfo >&
      board_info_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::price::BoardInfo >*
      mutable_board_info_list();
  
  // repeated .price.BedGroup product_bed_group = 2;
  inline int product_bed_group_size() const;
  inline void clear_product_bed_group();
  static const int kProductBedGroupFieldNumber = 2;
  inline const ::price::BedGroup& product_bed_group(int index) const;
  inline ::price::BedGroup* mutable_product_bed_group(int index);
  inline ::price::BedGroup* add_product_bed_group();
  inline const ::google::protobuf::RepeatedPtrField< ::price::BedGroup >&
      product_bed_group() const;
  inline ::google::protobuf::RepeatedPtrField< ::price::BedGroup >*
      mutable_product_bed_group();
  
  // optional bytes rate_comment = 3;
  inline bool has_rate_comment() const;
  inline void clear_rate_comment();
  static const int kRateCommentFieldNumber = 3;
  inline const ::std::string& rate_comment() const;
  inline void set_rate_comment(const ::std::string& value);
  inline void set_rate_comment(const char* value);
  inline void set_rate_comment(const void* value, size_t size);
  inline ::std::string* mutable_rate_comment();
  inline ::std::string* release_rate_comment();
  
  // optional bytes prepay_desc = 4;
  inline bool has_prepay_desc() const;
  inline void clear_prepay_desc();
  static const int kPrepayDescFieldNumber = 4;
  inline const ::std::string& prepay_desc() const;
  inline void set_prepay_desc(const ::std::string& value);
  inline void set_prepay_desc(const char* value);
  inline void set_prepay_desc(const void* value, size_t size);
  inline ::std::string* mutable_prepay_desc();
  inline ::std::string* release_prepay_desc();
  
  // optional bytes cancellation_desc_cn = 5;
  inline bool has_cancellation_desc_cn() const;
  inline void clear_cancellation_desc_cn();
  static const int kCancellationDescCnFieldNumber = 5;
  inline const ::std::string& cancellation_desc_cn() const;
  inline void set_cancellation_desc_cn(const ::std::string& value);
  inline void set_cancellation_desc_cn(const char* value);
  inline void set_cancellation_desc_cn(const void* value, size_t size);
  inline ::std::string* mutable_cancellation_desc_cn();
  inline ::std::string* release_cancellation_desc_cn();
  
  // optional bytes cancellation_desc_en = 6;
  inline bool has_cancellation_desc_en() const;
  inline void clear_cancellation_desc_en();
  static const int kCancellationDescEnFieldNumber = 6;
  inline const ::std::string& cancellation_desc_en() const;
  inline void set_cancellation_desc_en(const ::std::string& value);
  inline void set_cancellation_desc_en(const char* value);
  inline void set_cancellation_desc_en(const void* value, size_t size);
  inline ::std::string* mutable_cancellation_desc_en();
  inline ::std::string* release_cancellation_desc_en();
  
  // repeated .price.CreditCard product_credit_card = 7;
  inline int product_credit_card_size() const;
  inline void clear_product_credit_card();
  static const int kProductCreditCardFieldNumber = 7;
  inline const ::price::CreditCard& product_credit_card(int index) const;
  inline ::price::CreditCard* mutable_product_credit_card(int index);
  inline ::price::CreditCard* add_product_credit_card();
  inline const ::google::protobuf::RepeatedPtrField< ::price::CreditCard >&
      product_credit_card() const;
  inline ::google::protobuf::RepeatedPtrField< ::price::CreditCard >*
      mutable_product_credit_card();
  
  // @@protoc_insertion_point(class_scope:price.ProductDesc)
 private:
  inline void set_has_rate_comment();
  inline void clear_has_rate_comment();
  inline void set_has_prepay_desc();
  inline void clear_has_prepay_desc();
  inline void set_has_cancellation_desc_cn();
  inline void clear_has_cancellation_desc_cn();
  inline void set_has_cancellation_desc_en();
  inline void clear_has_cancellation_desc_en();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::price::BoardInfo > board_info_list_;
  ::google::protobuf::RepeatedPtrField< ::price::BedGroup > product_bed_group_;
  ::std::string* rate_comment_;
  ::std::string* prepay_desc_;
  ::std::string* cancellation_desc_cn_;
  ::std::string* cancellation_desc_en_;
  ::google::protobuf::RepeatedPtrField< ::price::CreditCard > product_credit_card_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];
  
  friend void  protobuf_AddDesc_price_5ftypes_2eproto();
  friend void protobuf_AssignDesc_price_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_price_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static ProductDesc* default_instance_;
};
// -------------------------------------------------------------------

class RoomDesc : public ::google::protobuf::Message {
 public:
  RoomDesc();
  virtual ~RoomDesc();
  
  RoomDesc(const RoomDesc& from);
  
  inline RoomDesc& operator=(const RoomDesc& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RoomDesc& default_instance();
  
  void Swap(RoomDesc* other);
  
  // implements Message ----------------------------------------------
  
  RoomDesc* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RoomDesc& from);
  void MergeFrom(const RoomDesc& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional bytes room_desc_text = 1;
  inline bool has_room_desc_text() const;
  inline void clear_room_desc_text();
  static const int kRoomDescTextFieldNumber = 1;
  inline const ::std::string& room_desc_text() const;
  inline void set_room_desc_text(const ::std::string& value);
  inline void set_room_desc_text(const char* value);
  inline void set_room_desc_text(const void* value, size_t size);
  inline ::std::string* mutable_room_desc_text();
  inline ::std::string* release_room_desc_text();
  
  // repeated .price.BedGroup room_bed_group = 2;
  inline int room_bed_group_size() const;
  inline void clear_room_bed_group();
  static const int kRoomBedGroupFieldNumber = 2;
  inline const ::price::BedGroup& room_bed_group(int index) const;
  inline ::price::BedGroup* mutable_room_bed_group(int index);
  inline ::price::BedGroup* add_room_bed_group();
  inline const ::google::protobuf::RepeatedPtrField< ::price::BedGroup >&
      room_bed_group() const;
  inline ::google::protobuf::RepeatedPtrField< ::price::BedGroup >*
      mutable_room_bed_group();
  
  // repeated .price.ImageLink image_link_list = 3;
  inline int image_link_list_size() const;
  inline void clear_image_link_list();
  static const int kImageLinkListFieldNumber = 3;
  inline const ::price::ImageLink& image_link_list(int index) const;
  inline ::price::ImageLink* mutable_image_link_list(int index);
  inline ::price::ImageLink* add_image_link_list();
  inline const ::google::protobuf::RepeatedPtrField< ::price::ImageLink >&
      image_link_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::price::ImageLink >*
      mutable_image_link_list();
  
  // optional bytes internet = 4;
  inline bool has_internet() const;
  inline void clear_internet();
  static const int kInternetFieldNumber = 4;
  inline const ::std::string& internet() const;
  inline void set_internet(const ::std::string& value);
  inline void set_internet(const char* value);
  inline void set_internet(const void* value, size_t size);
  inline ::std::string* mutable_internet();
  inline ::std::string* release_internet();
  
  // optional bytes smoking_preferences = 5;
  inline bool has_smoking_preferences() const;
  inline void clear_smoking_preferences();
  static const int kSmokingPreferencesFieldNumber = 5;
  inline const ::std::string& smoking_preferences() const;
  inline void set_smoking_preferences(const ::std::string& value);
  inline void set_smoking_preferences(const char* value);
  inline void set_smoking_preferences(const void* value, size_t size);
  inline ::std::string* mutable_smoking_preferences();
  inline ::std::string* release_smoking_preferences();
  
  // optional bytes meal_desc = 6;
  inline bool has_meal_desc() const;
  inline void clear_meal_desc();
  static const int kMealDescFieldNumber = 6;
  inline const ::std::string& meal_desc() const;
  inline void set_meal_desc(const ::std::string& value);
  inline void set_meal_desc(const char* value);
  inline void set_meal_desc(const void* value, size_t size);
  inline ::std::string* mutable_meal_desc();
  inline ::std::string* release_meal_desc();
  
  // optional bytes room_size = 7;
  inline bool has_room_size() const;
  inline void clear_room_size();
  static const int kRoomSizeFieldNumber = 7;
  inline const ::std::string& room_size() const;
  inline void set_room_size(const ::std::string& value);
  inline void set_room_size(const char* value);
  inline void set_room_size(const void* value, size_t size);
  inline ::std::string* mutable_room_size();
  inline ::std::string* release_room_size();
  
  // optional int32 has_window = 8 [default = 2];
  inline bool has_has_window() const;
  inline void clear_has_window();
  static const int kHasWindowFieldNumber = 8;
  inline ::google::protobuf::int32 has_window() const;
  inline void set_has_window(::google::protobuf::int32 value);
  
  // repeated bytes facility_list = 10;
  inline int facility_list_size() const;
  inline void clear_facility_list();
  static const int kFacilityListFieldNumber = 10;
  inline const ::std::string& facility_list(int index) const;
  inline ::std::string* mutable_facility_list(int index);
  inline void set_facility_list(int index, const ::std::string& value);
  inline void set_facility_list(int index, const char* value);
  inline void set_facility_list(int index, const void* value, size_t size);
  inline ::std::string* add_facility_list();
  inline void add_facility_list(const ::std::string& value);
  inline void add_facility_list(const char* value);
  inline void add_facility_list(const void* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& facility_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_facility_list();
  
  // @@protoc_insertion_point(class_scope:price.RoomDesc)
 private:
  inline void set_has_room_desc_text();
  inline void clear_has_room_desc_text();
  inline void set_has_internet();
  inline void clear_has_internet();
  inline void set_has_smoking_preferences();
  inline void clear_has_smoking_preferences();
  inline void set_has_meal_desc();
  inline void clear_has_meal_desc();
  inline void set_has_room_size();
  inline void clear_has_room_size();
  inline void set_has_has_window();
  inline void clear_has_has_window();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* room_desc_text_;
  ::google::protobuf::RepeatedPtrField< ::price::BedGroup > room_bed_group_;
  ::google::protobuf::RepeatedPtrField< ::price::ImageLink > image_link_list_;
  ::std::string* internet_;
  ::std::string* smoking_preferences_;
  ::std::string* meal_desc_;
  ::std::string* room_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> facility_list_;
  ::google::protobuf::int32 has_window_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];
  
  friend void  protobuf_AddDesc_price_5ftypes_2eproto();
  friend void protobuf_AssignDesc_price_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_price_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static RoomDesc* default_instance_;
};
// -------------------------------------------------------------------

class ProductFilter : public ::google::protobuf::Message {
 public:
  ProductFilter();
  virtual ~ProductFilter();
  
  ProductFilter(const ProductFilter& from);
  
  inline ProductFilter& operator=(const ProductFilter& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ProductFilter& default_instance();
  
  void Swap(ProductFilter* other);
  
  // implements Message ----------------------------------------------
  
  ProductFilter* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ProductFilter& from);
  void MergeFrom(const ProductFilter& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 filter_cancellation_type = 1;
  inline bool has_filter_cancellation_type() const;
  inline void clear_filter_cancellation_type();
  static const int kFilterCancellationTypeFieldNumber = 1;
  inline ::google::protobuf::int32 filter_cancellation_type() const;
  inline void set_filter_cancellation_type(::google::protobuf::int32 value);
  
  // optional int32 filter_paytype = 2;
  inline bool has_filter_paytype() const;
  inline void clear_filter_paytype();
  static const int kFilterPaytypeFieldNumber = 2;
  inline ::google::protobuf::int32 filter_paytype() const;
  inline void set_filter_paytype(::google::protobuf::int32 value);
  
  // optional int32 filter_internet = 3;
  inline bool has_filter_internet() const;
  inline void clear_filter_internet();
  static const int kFilterInternetFieldNumber = 3;
  inline ::google::protobuf::int32 filter_internet() const;
  inline void set_filter_internet(::google::protobuf::int32 value);
  
  // optional int32 filter_boards = 4;
  inline bool has_filter_boards() const;
  inline void clear_filter_boards();
  static const int kFilterBoardsFieldNumber = 4;
  inline ::google::protobuf::int32 filter_boards() const;
  inline void set_filter_boards(::google::protobuf::int32 value);
  
  // repeated int32 filter_beds = 5;
  inline int filter_beds_size() const;
  inline void clear_filter_beds();
  static const int kFilterBedsFieldNumber = 5;
  inline ::google::protobuf::int32 filter_beds(int index) const;
  inline void set_filter_beds(int index, ::google::protobuf::int32 value);
  inline void add_filter_beds(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      filter_beds() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_filter_beds();
  
  // @@protoc_insertion_point(class_scope:price.ProductFilter)
 private:
  inline void set_has_filter_cancellation_type();
  inline void clear_has_filter_cancellation_type();
  inline void set_has_filter_paytype();
  inline void clear_has_filter_paytype();
  inline void set_has_filter_internet();
  inline void clear_has_filter_internet();
  inline void set_has_filter_boards();
  inline void clear_has_filter_boards();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int32 filter_cancellation_type_;
  ::google::protobuf::int32 filter_paytype_;
  ::google::protobuf::int32 filter_internet_;
  ::google::protobuf::int32 filter_boards_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > filter_beds_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  friend void  protobuf_AddDesc_price_5ftypes_2eproto();
  friend void protobuf_AssignDesc_price_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_price_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static ProductFilter* default_instance_;
};
// -------------------------------------------------------------------

class ProductFilterStat : public ::google::protobuf::Message {
 public:
  ProductFilterStat();
  virtual ~ProductFilterStat();
  
  ProductFilterStat(const ProductFilterStat& from);
  
  inline ProductFilterStat& operator=(const ProductFilterStat& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ProductFilterStat& default_instance();
  
  void Swap(ProductFilterStat* other);
  
  // implements Message ----------------------------------------------
  
  ProductFilterStat* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ProductFilterStat& from);
  void MergeFrom(const ProductFilterStat& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated int32 filter_cancellation_type = 1;
  inline int filter_cancellation_type_size() const;
  inline void clear_filter_cancellation_type();
  static const int kFilterCancellationTypeFieldNumber = 1;
  inline ::google::protobuf::int32 filter_cancellation_type(int index) const;
  inline void set_filter_cancellation_type(int index, ::google::protobuf::int32 value);
  inline void add_filter_cancellation_type(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      filter_cancellation_type() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_filter_cancellation_type();
  
  // repeated int32 filter_paytype = 2;
  inline int filter_paytype_size() const;
  inline void clear_filter_paytype();
  static const int kFilterPaytypeFieldNumber = 2;
  inline ::google::protobuf::int32 filter_paytype(int index) const;
  inline void set_filter_paytype(int index, ::google::protobuf::int32 value);
  inline void add_filter_paytype(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      filter_paytype() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_filter_paytype();
  
  // repeated int32 filter_internet = 3;
  inline int filter_internet_size() const;
  inline void clear_filter_internet();
  static const int kFilterInternetFieldNumber = 3;
  inline ::google::protobuf::int32 filter_internet(int index) const;
  inline void set_filter_internet(int index, ::google::protobuf::int32 value);
  inline void add_filter_internet(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      filter_internet() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_filter_internet();
  
  // repeated int32 filter_boards = 4;
  inline int filter_boards_size() const;
  inline void clear_filter_boards();
  static const int kFilterBoardsFieldNumber = 4;
  inline ::google::protobuf::int32 filter_boards(int index) const;
  inline void set_filter_boards(int index, ::google::protobuf::int32 value);
  inline void add_filter_boards(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      filter_boards() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_filter_boards();
  
  // repeated int32 filter_beds = 5;
  inline int filter_beds_size() const;
  inline void clear_filter_beds();
  static const int kFilterBedsFieldNumber = 5;
  inline ::google::protobuf::int32 filter_beds(int index) const;
  inline void set_filter_beds(int index, ::google::protobuf::int32 value);
  inline void add_filter_beds(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      filter_beds() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_filter_beds();
  
  // @@protoc_insertion_point(class_scope:price.ProductFilterStat)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > filter_cancellation_type_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > filter_paytype_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > filter_internet_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > filter_boards_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > filter_beds_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  friend void  protobuf_AddDesc_price_5ftypes_2eproto();
  friend void protobuf_AssignDesc_price_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_price_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static ProductFilterStat* default_instance_;
};
// -------------------------------------------------------------------

class PriceInfo : public ::google::protobuf::Message {
 public:
  PriceInfo();
  virtual ~PriceInfo();
  
  PriceInfo(const PriceInfo& from);
  
  inline PriceInfo& operator=(const PriceInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const PriceInfo& default_instance();
  
  void Swap(PriceInfo* other);
  
  // implements Message ----------------------------------------------
  
  PriceInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PriceInfo& from);
  void MergeFrom(const PriceInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional .price.PriceItem total_price = 1;
  inline bool has_total_price() const;
  inline void clear_total_price();
  static const int kTotalPriceFieldNumber = 1;
  inline const ::price::PriceItem& total_price() const;
  inline ::price::PriceItem* mutable_total_price();
  inline ::price::PriceItem* release_total_price();
  
  // optional .price.PriceItem total_price_ori = 2;
  inline bool has_total_price_ori() const;
  inline void clear_total_price_ori();
  static const int kTotalPriceOriFieldNumber = 2;
  inline const ::price::PriceItem& total_price_ori() const;
  inline ::price::PriceItem* mutable_total_price_ori();
  inline ::price::PriceItem* release_total_price_ori();
  
  // optional .price.PriceItem total_room_price = 3;
  inline bool has_total_room_price() const;
  inline void clear_total_room_price();
  static const int kTotalRoomPriceFieldNumber = 3;
  inline const ::price::PriceItem& total_room_price() const;
  inline ::price::PriceItem* mutable_total_room_price();
  inline ::price::PriceItem* release_total_room_price();
  
  // optional .price.ExtraCharge extra_charge = 4;
  inline bool has_extra_charge() const;
  inline void clear_extra_charge();
  static const int kExtraChargeFieldNumber = 4;
  inline const ::price::ExtraCharge& extra_charge() const;
  inline ::price::ExtraCharge* mutable_extra_charge();
  inline ::price::ExtraCharge* release_extra_charge();
  
  // repeated .price.DailyPrice daily_price_list = 5;
  inline int daily_price_list_size() const;
  inline void clear_daily_price_list();
  static const int kDailyPriceListFieldNumber = 5;
  inline const ::price::DailyPrice& daily_price_list(int index) const;
  inline ::price::DailyPrice* mutable_daily_price_list(int index);
  inline ::price::DailyPrice* add_daily_price_list();
  inline const ::google::protobuf::RepeatedPtrField< ::price::DailyPrice >&
      daily_price_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::price::DailyPrice >*
      mutable_daily_price_list();
  
  // optional .price.PriceItem average_price = 6;
  inline bool has_average_price() const;
  inline void clear_average_price();
  static const int kAveragePriceFieldNumber = 6;
  inline const ::price::PriceItem& average_price() const;
  inline ::price::PriceItem* mutable_average_price();
  inline ::price::PriceItem* release_average_price();
  
  // optional .price.PriceItem average_room_price = 7;
  inline bool has_average_room_price() const;
  inline void clear_average_room_price();
  static const int kAverageRoomPriceFieldNumber = 7;
  inline const ::price::PriceItem& average_room_price() const;
  inline ::price::PriceItem* mutable_average_room_price();
  inline ::price::PriceItem* release_average_room_price();
  
  // optional .price.PriceItem addition_price = 8;
  inline bool has_addition_price() const;
  inline void clear_addition_price();
  static const int kAdditionPriceFieldNumber = 8;
  inline const ::price::PriceItem& addition_price() const;
  inline ::price::PriceItem* mutable_addition_price();
  inline ::price::PriceItem* release_addition_price();
  
  // optional .price.PriceItem sort_price = 9;
  inline bool has_sort_price() const;
  inline void clear_sort_price();
  static const int kSortPriceFieldNumber = 9;
  inline const ::price::PriceItem& sort_price() const;
  inline ::price::PriceItem* mutable_sort_price();
  inline ::price::PriceItem* release_sort_price();
  
  // @@protoc_insertion_point(class_scope:price.PriceInfo)
 private:
  inline void set_has_total_price();
  inline void clear_has_total_price();
  inline void set_has_total_price_ori();
  inline void clear_has_total_price_ori();
  inline void set_has_total_room_price();
  inline void clear_has_total_room_price();
  inline void set_has_extra_charge();
  inline void clear_has_extra_charge();
  inline void set_has_average_price();
  inline void clear_has_average_price();
  inline void set_has_average_room_price();
  inline void clear_has_average_room_price();
  inline void set_has_addition_price();
  inline void clear_has_addition_price();
  inline void set_has_sort_price();
  inline void clear_has_sort_price();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::price::PriceItem* total_price_;
  ::price::PriceItem* total_price_ori_;
  ::price::PriceItem* total_room_price_;
  ::price::ExtraCharge* extra_charge_;
  ::google::protobuf::RepeatedPtrField< ::price::DailyPrice > daily_price_list_;
  ::price::PriceItem* average_price_;
  ::price::PriceItem* average_room_price_;
  ::price::PriceItem* addition_price_;
  ::price::PriceItem* sort_price_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];
  
  friend void  protobuf_AddDesc_price_5ftypes_2eproto();
  friend void protobuf_AssignDesc_price_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_price_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static PriceInfo* default_instance_;
};
// -------------------------------------------------------------------

class PersonHold : public ::google::protobuf::Message {
 public:
  PersonHold();
  virtual ~PersonHold();
  
  PersonHold(const PersonHold& from);
  
  inline PersonHold& operator=(const PersonHold& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const PersonHold& default_instance();
  
  void Swap(PersonHold* other);
  
  // implements Message ----------------------------------------------
  
  PersonHold* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PersonHold& from);
  void MergeFrom(const PersonHold& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 max_person_num = 1;
  inline bool has_max_person_num() const;
  inline void clear_max_person_num();
  static const int kMaxPersonNumFieldNumber = 1;
  inline ::google::protobuf::int32 max_person_num() const;
  inline void set_max_person_num(::google::protobuf::int32 value);
  
  // optional int32 max_adult_num = 2;
  inline bool has_max_adult_num() const;
  inline void clear_max_adult_num();
  static const int kMaxAdultNumFieldNumber = 2;
  inline ::google::protobuf::int32 max_adult_num() const;
  inline void set_max_adult_num(::google::protobuf::int32 value);
  
  // optional int32 max_child_num = 3;
  inline bool has_max_child_num() const;
  inline void clear_max_child_num();
  static const int kMaxChildNumFieldNumber = 3;
  inline ::google::protobuf::int32 max_child_num() const;
  inline void set_max_child_num(::google::protobuf::int32 value);
  
  // optional int32 max_child_age = 4;
  inline bool has_max_child_age() const;
  inline void clear_max_child_age();
  static const int kMaxChildAgeFieldNumber = 4;
  inline ::google::protobuf::int32 max_child_age() const;
  inline void set_max_child_age(::google::protobuf::int32 value);
  
  // optional int32 min_child_alone_age = 5;
  inline bool has_min_child_alone_age() const;
  inline void clear_min_child_alone_age();
  static const int kMinChildAloneAgeFieldNumber = 5;
  inline ::google::protobuf::int32 min_child_alone_age() const;
  inline void set_min_child_alone_age(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:price.PersonHold)
 private:
  inline void set_has_max_person_num();
  inline void clear_has_max_person_num();
  inline void set_has_max_adult_num();
  inline void clear_has_max_adult_num();
  inline void set_has_max_child_num();
  inline void clear_has_max_child_num();
  inline void set_has_max_child_age();
  inline void clear_has_max_child_age();
  inline void set_has_min_child_alone_age();
  inline void clear_has_min_child_alone_age();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int32 max_person_num_;
  ::google::protobuf::int32 max_adult_num_;
  ::google::protobuf::int32 max_child_num_;
  ::google::protobuf::int32 max_child_age_;
  ::google::protobuf::int32 min_child_alone_age_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  friend void  protobuf_AddDesc_price_5ftypes_2eproto();
  friend void protobuf_AssignDesc_price_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_price_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static PersonHold* default_instance_;
};
// -------------------------------------------------------------------

class Product : public ::google::protobuf::Message {
 public:
  Product();
  virtual ~Product();
  
  Product(const Product& from);
  
  inline Product& operator=(const Product& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Product& default_instance();
  
  void Swap(Product* other);
  
  // implements Message ----------------------------------------------
  
  Product* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Product& from);
  void MergeFrom(const Product& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int64 elong_pid = 1;
  inline bool has_elong_pid() const;
  inline void clear_elong_pid();
  static const int kElongPidFieldNumber = 1;
  inline ::google::protobuf::int64 elong_pid() const;
  inline void set_elong_pid(::google::protobuf::int64 value);
  
  // optional string ota_pid = 3;
  inline bool has_ota_pid() const;
  inline void clear_ota_pid();
  static const int kOtaPidFieldNumber = 3;
  inline const ::std::string& ota_pid() const;
  inline void set_ota_pid(const ::std::string& value);
  inline void set_ota_pid(const char* value);
  inline void set_ota_pid(const char* value, size_t size);
  inline ::std::string* mutable_ota_pid();
  inline ::std::string* release_ota_pid();
  
  // optional bytes product_name_cn = 4;
  inline bool has_product_name_cn() const;
  inline void clear_product_name_cn();
  static const int kProductNameCnFieldNumber = 4;
  inline const ::std::string& product_name_cn() const;
  inline void set_product_name_cn(const ::std::string& value);
  inline void set_product_name_cn(const char* value);
  inline void set_product_name_cn(const void* value, size_t size);
  inline ::std::string* mutable_product_name_cn();
  inline ::std::string* release_product_name_cn();
  
  // optional bytes product_name_en = 5;
  inline bool has_product_name_en() const;
  inline void clear_product_name_en();
  static const int kProductNameEnFieldNumber = 5;
  inline const ::std::string& product_name_en() const;
  inline void set_product_name_en(const ::std::string& value);
  inline void set_product_name_en(const char* value);
  inline void set_product_name_en(const void* value, size_t size);
  inline ::std::string* mutable_product_name_en();
  inline ::std::string* release_product_name_en();
  
  // optional .price.RatePlan rateplan = 6;
  inline bool has_rateplan() const;
  inline void clear_rateplan();
  static const int kRateplanFieldNumber = 6;
  inline const ::price::RatePlan& rateplan() const;
  inline ::price::RatePlan* mutable_rateplan();
  inline ::price::RatePlan* release_rateplan();
  
  // optional .price.ProductDesc product_desc = 8;
  inline bool has_product_desc() const;
  inline void clear_product_desc();
  static const int kProductDescFieldNumber = 8;
  inline const ::price::ProductDesc& product_desc() const;
  inline ::price::ProductDesc* mutable_product_desc();
  inline ::price::ProductDesc* release_product_desc();
  
  // required int32 room_num = 9;
  inline bool has_room_num() const;
  inline void clear_room_num();
  static const int kRoomNumFieldNumber = 9;
  inline ::google::protobuf::int32 room_num() const;
  inline void set_room_num(::google::protobuf::int32 value);
  
  // repeated .price.PromotionInfo promotion_info = 10;
  inline int promotion_info_size() const;
  inline void clear_promotion_info();
  static const int kPromotionInfoFieldNumber = 10;
  inline const ::price::PromotionInfo& promotion_info(int index) const;
  inline ::price::PromotionInfo* mutable_promotion_info(int index);
  inline ::price::PromotionInfo* add_promotion_info();
  inline const ::google::protobuf::RepeatedPtrField< ::price::PromotionInfo >&
      promotion_info() const;
  inline ::google::protobuf::RepeatedPtrField< ::price::PromotionInfo >*
      mutable_promotion_info();
  
  // optional .price.ProductFilter product_filter = 11;
  inline bool has_product_filter() const;
  inline void clear_product_filter();
  static const int kProductFilterFieldNumber = 11;
  inline const ::price::ProductFilter& product_filter() const;
  inline ::price::ProductFilter* mutable_product_filter();
  inline ::price::ProductFilter* release_product_filter();
  
  // optional string attachment = 12;
  inline bool has_attachment() const;
  inline void clear_attachment();
  static const int kAttachmentFieldNumber = 12;
  inline const ::std::string& attachment() const;
  inline void set_attachment(const ::std::string& value);
  inline void set_attachment(const char* value);
  inline void set_attachment(const char* value, size_t size);
  inline ::std::string* mutable_attachment();
  inline ::std::string* release_attachment();
  
  // optional .price.PriceInfo booking_price = 20;
  inline bool has_booking_price() const;
  inline void clear_booking_price();
  static const int kBookingPriceFieldNumber = 20;
  inline const ::price::PriceInfo& booking_price() const;
  inline ::price::PriceInfo* mutable_booking_price();
  inline ::price::PriceInfo* release_booking_price();
  
  // optional .price.PriceInfo cost_price = 21;
  inline bool has_cost_price() const;
  inline void clear_cost_price();
  static const int kCostPriceFieldNumber = 21;
  inline const ::price::PriceInfo& cost_price() const;
  inline ::price::PriceInfo* mutable_cost_price();
  inline ::price::PriceInfo* release_cost_price();
  
  // optional .price.PriceInfo origin_price = 22;
  inline bool has_origin_price() const;
  inline void clear_origin_price();
  static const int kOriginPriceFieldNumber = 22;
  inline const ::price::PriceInfo& origin_price() const;
  inline ::price::PriceInfo* mutable_origin_price();
  inline ::price::PriceInfo* release_origin_price();
  
  // optional .price.PriceInfo sale_price = 23;
  inline bool has_sale_price() const;
  inline void clear_sale_price();
  static const int kSalePriceFieldNumber = 23;
  inline const ::price::PriceInfo& sale_price() const;
  inline ::price::PriceInfo* mutable_sale_price();
  inline ::price::PriceInfo* release_sale_price();
  
  // optional int32 source_ota_id = 50 [default = -1];
  inline bool has_source_ota_id() const;
  inline void clear_source_ota_id();
  static const int kSourceOtaIdFieldNumber = 50;
  inline ::google::protobuf::int32 source_ota_id() const;
  inline void set_source_ota_id(::google::protobuf::int32 value);
  
  // optional int64 ota_sign = 51;
  inline bool has_ota_sign() const;
  inline void clear_ota_sign();
  static const int kOtaSignFieldNumber = 51;
  inline ::google::protobuf::int64 ota_sign() const;
  inline void set_ota_sign(::google::protobuf::int64 value);
  
  // repeated .price.Tag tag = 24;
  inline int tag_size() const;
  inline void clear_tag();
  static const int kTagFieldNumber = 24;
  inline const ::price::Tag& tag(int index) const;
  inline ::price::Tag* mutable_tag(int index);
  inline ::price::Tag* add_tag();
  inline const ::google::protobuf::RepeatedPtrField< ::price::Tag >&
      tag() const;
  inline ::google::protobuf::RepeatedPtrField< ::price::Tag >*
      mutable_tag();
  
  // @@protoc_insertion_point(class_scope:price.Product)
 private:
  inline void set_has_elong_pid();
  inline void clear_has_elong_pid();
  inline void set_has_ota_pid();
  inline void clear_has_ota_pid();
  inline void set_has_product_name_cn();
  inline void clear_has_product_name_cn();
  inline void set_has_product_name_en();
  inline void clear_has_product_name_en();
  inline void set_has_rateplan();
  inline void clear_has_rateplan();
  inline void set_has_product_desc();
  inline void clear_has_product_desc();
  inline void set_has_room_num();
  inline void clear_has_room_num();
  inline void set_has_product_filter();
  inline void clear_has_product_filter();
  inline void set_has_attachment();
  inline void clear_has_attachment();
  inline void set_has_booking_price();
  inline void clear_has_booking_price();
  inline void set_has_cost_price();
  inline void clear_has_cost_price();
  inline void set_has_origin_price();
  inline void clear_has_origin_price();
  inline void set_has_sale_price();
  inline void clear_has_sale_price();
  inline void set_has_source_ota_id();
  inline void clear_has_source_ota_id();
  inline void set_has_ota_sign();
  inline void clear_has_ota_sign();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int64 elong_pid_;
  ::std::string* ota_pid_;
  ::std::string* product_name_cn_;
  ::std::string* product_name_en_;
  ::price::RatePlan* rateplan_;
  ::price::ProductDesc* product_desc_;
  ::google::protobuf::RepeatedPtrField< ::price::PromotionInfo > promotion_info_;
  ::price::ProductFilter* product_filter_;
  ::std::string* attachment_;
  ::price::PriceInfo* booking_price_;
  ::google::protobuf::int32 room_num_;
  ::google::protobuf::int32 source_ota_id_;
  ::price::PriceInfo* cost_price_;
  ::price::PriceInfo* origin_price_;
  ::price::PriceInfo* sale_price_;
  ::google::protobuf::int64 ota_sign_;
  ::google::protobuf::RepeatedPtrField< ::price::Tag > tag_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(17 + 31) / 32];
  
  friend void  protobuf_AddDesc_price_5ftypes_2eproto();
  friend void protobuf_AssignDesc_price_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_price_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static Product* default_instance_;
};
// -------------------------------------------------------------------

class Room : public ::google::protobuf::Message {
 public:
  Room();
  virtual ~Room();
  
  Room(const Room& from);
  
  inline Room& operator=(const Room& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Room& default_instance();
  
  void Swap(Room* other);
  
  // implements Message ----------------------------------------------
  
  Room* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Room& from);
  void MergeFrom(const Room& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int64 mroom_id = 1;
  inline bool has_mroom_id() const;
  inline void clear_mroom_id();
  static const int kMroomIdFieldNumber = 1;
  inline ::google::protobuf::int64 mroom_id() const;
  inline void set_mroom_id(::google::protobuf::int64 value);
  
  // optional bytes mroom_name_cn = 2;
  inline bool has_mroom_name_cn() const;
  inline void clear_mroom_name_cn();
  static const int kMroomNameCnFieldNumber = 2;
  inline const ::std::string& mroom_name_cn() const;
  inline void set_mroom_name_cn(const ::std::string& value);
  inline void set_mroom_name_cn(const char* value);
  inline void set_mroom_name_cn(const void* value, size_t size);
  inline ::std::string* mutable_mroom_name_cn();
  inline ::std::string* release_mroom_name_cn();
  
  // optional bytes mroom_name_en = 3;
  inline bool has_mroom_name_en() const;
  inline void clear_mroom_name_en();
  static const int kMroomNameEnFieldNumber = 3;
  inline const ::std::string& mroom_name_en() const;
  inline void set_mroom_name_en(const ::std::string& value);
  inline void set_mroom_name_en(const char* value);
  inline void set_mroom_name_en(const void* value, size_t size);
  inline ::std::string* mutable_mroom_name_en();
  inline ::std::string* release_mroom_name_en();
  
  // required int64 room_id = 4;
  inline bool has_room_id() const;
  inline void clear_room_id();
  static const int kRoomIdFieldNumber = 4;
  inline ::google::protobuf::int64 room_id() const;
  inline void set_room_id(::google::protobuf::int64 value);
  
  // required bytes room_name_cn = 5;
  inline bool has_room_name_cn() const;
  inline void clear_room_name_cn();
  static const int kRoomNameCnFieldNumber = 5;
  inline const ::std::string& room_name_cn() const;
  inline void set_room_name_cn(const ::std::string& value);
  inline void set_room_name_cn(const char* value);
  inline void set_room_name_cn(const void* value, size_t size);
  inline ::std::string* mutable_room_name_cn();
  inline ::std::string* release_room_name_cn();
  
  // optional bytes room_name_en = 6;
  inline bool has_room_name_en() const;
  inline void clear_room_name_en();
  static const int kRoomNameEnFieldNumber = 6;
  inline const ::std::string& room_name_en() const;
  inline void set_room_name_en(const ::std::string& value);
  inline void set_room_name_en(const char* value);
  inline void set_room_name_en(const void* value, size_t size);
  inline ::std::string* mutable_room_name_en();
  inline ::std::string* release_room_name_en();
  
  // required int32 room_status = 7;
  inline bool has_room_status() const;
  inline void clear_room_status();
  static const int kRoomStatusFieldNumber = 7;
  inline ::google::protobuf::int32 room_status() const;
  inline void set_room_status(::google::protobuf::int32 value);
  
  // optional int32 allotment = 8 [default = -1];
  inline bool has_allotment() const;
  inline void clear_allotment();
  static const int kAllotmentFieldNumber = 8;
  inline ::google::protobuf::int32 allotment() const;
  inline void set_allotment(::google::protobuf::int32 value);
  
  // optional .price.PersonHold person_hold = 9;
  inline bool has_person_hold() const;
  inline void clear_person_hold();
  static const int kPersonHoldFieldNumber = 9;
  inline const ::price::PersonHold& person_hold() const;
  inline ::price::PersonHold* mutable_person_hold();
  inline ::price::PersonHold* release_person_hold();
  
  // optional .price.RoomDesc room_desc = 10;
  inline bool has_room_desc() const;
  inline void clear_room_desc();
  static const int kRoomDescFieldNumber = 10;
  inline const ::price::RoomDesc& room_desc() const;
  inline ::price::RoomDesc* mutable_room_desc();
  inline ::price::RoomDesc* release_room_desc();
  
  // optional string attachment = 11;
  inline bool has_attachment() const;
  inline void clear_attachment();
  static const int kAttachmentFieldNumber = 11;
  inline const ::std::string& attachment() const;
  inline void set_attachment(const ::std::string& value);
  inline void set_attachment(const char* value);
  inline void set_attachment(const char* value, size_t size);
  inline ::std::string* mutable_attachment();
  inline ::std::string* release_attachment();
  
  // repeated .price.Product product_list = 12;
  inline int product_list_size() const;
  inline void clear_product_list();
  static const int kProductListFieldNumber = 12;
  inline const ::price::Product& product_list(int index) const;
  inline ::price::Product* mutable_product_list(int index);
  inline ::price::Product* add_product_list();
  inline const ::google::protobuf::RepeatedPtrField< ::price::Product >&
      product_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::price::Product >*
      mutable_product_list();
  
  // optional .price.PriceInfo base_price = 21;
  inline bool has_base_price() const;
  inline void clear_base_price();
  static const int kBasePriceFieldNumber = 21;
  inline const ::price::PriceInfo& base_price() const;
  inline ::price::PriceInfo* mutable_base_price();
  inline ::price::PriceInfo* release_base_price();
  
  // @@protoc_insertion_point(class_scope:price.Room)
 private:
  inline void set_has_mroom_id();
  inline void clear_has_mroom_id();
  inline void set_has_mroom_name_cn();
  inline void clear_has_mroom_name_cn();
  inline void set_has_mroom_name_en();
  inline void clear_has_mroom_name_en();
  inline void set_has_room_id();
  inline void clear_has_room_id();
  inline void set_has_room_name_cn();
  inline void clear_has_room_name_cn();
  inline void set_has_room_name_en();
  inline void clear_has_room_name_en();
  inline void set_has_room_status();
  inline void clear_has_room_status();
  inline void set_has_allotment();
  inline void clear_has_allotment();
  inline void set_has_person_hold();
  inline void clear_has_person_hold();
  inline void set_has_room_desc();
  inline void clear_has_room_desc();
  inline void set_has_attachment();
  inline void clear_has_attachment();
  inline void set_has_base_price();
  inline void clear_has_base_price();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int64 mroom_id_;
  ::std::string* mroom_name_cn_;
  ::std::string* mroom_name_en_;
  ::google::protobuf::int64 room_id_;
  ::std::string* room_name_cn_;
  ::std::string* room_name_en_;
  ::google::protobuf::int32 room_status_;
  ::google::protobuf::int32 allotment_;
  ::price::PersonHold* person_hold_;
  ::price::RoomDesc* room_desc_;
  ::std::string* attachment_;
  ::google::protobuf::RepeatedPtrField< ::price::Product > product_list_;
  ::price::PriceInfo* base_price_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(13 + 31) / 32];
  
  friend void  protobuf_AddDesc_price_5ftypes_2eproto();
  friend void protobuf_AssignDesc_price_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_price_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static Room* default_instance_;
};
// -------------------------------------------------------------------

class DetailOta : public ::google::protobuf::Message {
 public:
  DetailOta();
  virtual ~DetailOta();
  
  DetailOta(const DetailOta& from);
  
  inline DetailOta& operator=(const DetailOta& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const DetailOta& default_instance();
  
  void Swap(DetailOta* other);
  
  // implements Message ----------------------------------------------
  
  DetailOta* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DetailOta& from);
  void MergeFrom(const DetailOta& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 base_hotel_id = 1;
  inline bool has_base_hotel_id() const;
  inline void clear_base_hotel_id();
  static const int kBaseHotelIdFieldNumber = 1;
  inline ::google::protobuf::int32 base_hotel_id() const;
  inline void set_base_hotel_id(::google::protobuf::int32 value);
  
  // optional int64 crawl_time = 2;
  inline bool has_crawl_time() const;
  inline void clear_crawl_time();
  static const int kCrawlTimeFieldNumber = 2;
  inline ::google::protobuf::int64 crawl_time() const;
  inline void set_crawl_time(::google::protobuf::int64 value);
  
  // optional .price.PriceInfo base_price = 3;
  inline bool has_base_price() const;
  inline void clear_base_price();
  static const int kBasePriceFieldNumber = 3;
  inline const ::price::PriceInfo& base_price() const;
  inline ::price::PriceInfo* mutable_base_price();
  inline ::price::PriceInfo* release_base_price();
  
  // repeated .price.PromotionInfo promotion_info = 4;
  inline int promotion_info_size() const;
  inline void clear_promotion_info();
  static const int kPromotionInfoFieldNumber = 4;
  inline const ::price::PromotionInfo& promotion_info(int index) const;
  inline ::price::PromotionInfo* mutable_promotion_info(int index);
  inline ::price::PromotionInfo* add_promotion_info();
  inline const ::google::protobuf::RepeatedPtrField< ::price::PromotionInfo >&
      promotion_info() const;
  inline ::google::protobuf::RepeatedPtrField< ::price::PromotionInfo >*
      mutable_promotion_info();
  
  // required int32 ota_id = 11;
  inline bool has_ota_id() const;
  inline void clear_ota_id();
  static const int kOtaIdFieldNumber = 11;
  inline ::google::protobuf::int32 ota_id() const;
  inline void set_ota_id(::google::protobuf::int32 value);
  
  // optional string ota_hotel_id = 12;
  inline bool has_ota_hotel_id() const;
  inline void clear_ota_hotel_id();
  static const int kOtaHotelIdFieldNumber = 12;
  inline const ::std::string& ota_hotel_id() const;
  inline void set_ota_hotel_id(const ::std::string& value);
  inline void set_ota_hotel_id(const char* value);
  inline void set_ota_hotel_id(const char* value, size_t size);
  inline ::std::string* mutable_ota_hotel_id();
  inline ::std::string* release_ota_hotel_id();
  
  // required .price.HotelStatus hotel_status = 13;
  inline bool has_hotel_status() const;
  inline void clear_hotel_status();
  static const int kHotelStatusFieldNumber = 13;
  inline price::HotelStatus hotel_status() const;
  inline void set_hotel_status(price::HotelStatus value);
  
  // optional string attachment = 14;
  inline bool has_attachment() const;
  inline void clear_attachment();
  static const int kAttachmentFieldNumber = 14;
  inline const ::std::string& attachment() const;
  inline void set_attachment(const ::std::string& value);
  inline void set_attachment(const char* value);
  inline void set_attachment(const char* value, size_t size);
  inline ::std::string* mutable_attachment();
  inline ::std::string* release_attachment();
  
  // repeated .price.Room room_list = 15;
  inline int room_list_size() const;
  inline void clear_room_list();
  static const int kRoomListFieldNumber = 15;
  inline const ::price::Room& room_list(int index) const;
  inline ::price::Room* mutable_room_list(int index);
  inline ::price::Room* add_room_list();
  inline const ::google::protobuf::RepeatedPtrField< ::price::Room >&
      room_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::price::Room >*
      mutable_room_list();
  
  // @@protoc_insertion_point(class_scope:price.DetailOta)
 private:
  inline void set_has_base_hotel_id();
  inline void clear_has_base_hotel_id();
  inline void set_has_crawl_time();
  inline void clear_has_crawl_time();
  inline void set_has_base_price();
  inline void clear_has_base_price();
  inline void set_has_ota_id();
  inline void clear_has_ota_id();
  inline void set_has_ota_hotel_id();
  inline void clear_has_ota_hotel_id();
  inline void set_has_hotel_status();
  inline void clear_has_hotel_status();
  inline void set_has_attachment();
  inline void clear_has_attachment();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int64 crawl_time_;
  ::price::PriceInfo* base_price_;
  ::google::protobuf::int32 base_hotel_id_;
  ::google::protobuf::int32 ota_id_;
  ::google::protobuf::RepeatedPtrField< ::price::PromotionInfo > promotion_info_;
  ::std::string* ota_hotel_id_;
  ::std::string* attachment_;
  ::google::protobuf::RepeatedPtrField< ::price::Room > room_list_;
  int hotel_status_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];
  
  friend void  protobuf_AddDesc_price_5ftypes_2eproto();
  friend void protobuf_AssignDesc_price_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_price_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static DetailOta* default_instance_;
};
// -------------------------------------------------------------------

class DetailHotel : public ::google::protobuf::Message {
 public:
  DetailHotel();
  virtual ~DetailHotel();
  
  DetailHotel(const DetailHotel& from);
  
  inline DetailHotel& operator=(const DetailHotel& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const DetailHotel& default_instance();
  
  void Swap(DetailHotel* other);
  
  // implements Message ----------------------------------------------
  
  DetailHotel* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DetailHotel& from);
  void MergeFrom(const DetailHotel& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 base_hotel_id = 1;
  inline bool has_base_hotel_id() const;
  inline void clear_base_hotel_id();
  static const int kBaseHotelIdFieldNumber = 1;
  inline ::google::protobuf::int32 base_hotel_id() const;
  inline void set_base_hotel_id(::google::protobuf::int32 value);
  
  // optional int64 crawl_time = 2;
  inline bool has_crawl_time() const;
  inline void clear_crawl_time();
  static const int kCrawlTimeFieldNumber = 2;
  inline ::google::protobuf::int64 crawl_time() const;
  inline void set_crawl_time(::google::protobuf::int64 value);
  
  // repeated .price.PromotionInfo promotion_info = 4;
  inline int promotion_info_size() const;
  inline void clear_promotion_info();
  static const int kPromotionInfoFieldNumber = 4;
  inline const ::price::PromotionInfo& promotion_info(int index) const;
  inline ::price::PromotionInfo* mutable_promotion_info(int index);
  inline ::price::PromotionInfo* add_promotion_info();
  inline const ::google::protobuf::RepeatedPtrField< ::price::PromotionInfo >&
      promotion_info() const;
  inline ::google::protobuf::RepeatedPtrField< ::price::PromotionInfo >*
      mutable_promotion_info();
  
  // optional .price.ProductFilterStat product_filter_stat = 5;
  inline bool has_product_filter_stat() const;
  inline void clear_product_filter_stat();
  static const int kProductFilterStatFieldNumber = 5;
  inline const ::price::ProductFilterStat& product_filter_stat() const;
  inline ::price::ProductFilterStat* mutable_product_filter_stat();
  inline ::price::ProductFilterStat* release_product_filter_stat();
  
  // optional .price.PriceInfo base_price = 3;
  inline bool has_base_price() const;
  inline void clear_base_price();
  static const int kBasePriceFieldNumber = 3;
  inline const ::price::PriceInfo& base_price() const;
  inline ::price::PriceInfo* mutable_base_price();
  inline ::price::PriceInfo* release_base_price();
  
  // repeated .price.DetailOta detail_ota_list = 11;
  inline int detail_ota_list_size() const;
  inline void clear_detail_ota_list();
  static const int kDetailOtaListFieldNumber = 11;
  inline const ::price::DetailOta& detail_ota_list(int index) const;
  inline ::price::DetailOta* mutable_detail_ota_list(int index);
  inline ::price::DetailOta* add_detail_ota_list();
  inline const ::google::protobuf::RepeatedPtrField< ::price::DetailOta >&
      detail_ota_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::price::DetailOta >*
      mutable_detail_ota_list();
  
  // repeated .price.Tag tag = 12;
  inline int tag_size() const;
  inline void clear_tag();
  static const int kTagFieldNumber = 12;
  inline const ::price::Tag& tag(int index) const;
  inline ::price::Tag* mutable_tag(int index);
  inline ::price::Tag* add_tag();
  inline const ::google::protobuf::RepeatedPtrField< ::price::Tag >&
      tag() const;
  inline ::google::protobuf::RepeatedPtrField< ::price::Tag >*
      mutable_tag();
  
  // @@protoc_insertion_point(class_scope:price.DetailHotel)
 private:
  inline void set_has_base_hotel_id();
  inline void clear_has_base_hotel_id();
  inline void set_has_crawl_time();
  inline void clear_has_crawl_time();
  inline void set_has_product_filter_stat();
  inline void clear_has_product_filter_stat();
  inline void set_has_base_price();
  inline void clear_has_base_price();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int64 crawl_time_;
  ::google::protobuf::RepeatedPtrField< ::price::PromotionInfo > promotion_info_;
  ::price::ProductFilterStat* product_filter_stat_;
  ::price::PriceInfo* base_price_;
  ::google::protobuf::RepeatedPtrField< ::price::DetailOta > detail_ota_list_;
  ::google::protobuf::RepeatedPtrField< ::price::Tag > tag_;
  ::google::protobuf::int32 base_hotel_id_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];
  
  friend void  protobuf_AddDesc_price_5ftypes_2eproto();
  friend void protobuf_AssignDesc_price_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_price_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static DetailHotel* default_instance_;
};
// -------------------------------------------------------------------

class ListOta : public ::google::protobuf::Message {
 public:
  ListOta();
  virtual ~ListOta();
  
  ListOta(const ListOta& from);
  
  inline ListOta& operator=(const ListOta& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ListOta& default_instance();
  
  void Swap(ListOta* other);
  
  // implements Message ----------------------------------------------
  
  ListOta* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ListOta& from);
  void MergeFrom(const ListOta& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 base_hotel_id = 1;
  inline bool has_base_hotel_id() const;
  inline void clear_base_hotel_id();
  static const int kBaseHotelIdFieldNumber = 1;
  inline ::google::protobuf::int32 base_hotel_id() const;
  inline void set_base_hotel_id(::google::protobuf::int32 value);
  
  // optional int64 crawl_time = 2;
  inline bool has_crawl_time() const;
  inline void clear_crawl_time();
  static const int kCrawlTimeFieldNumber = 2;
  inline ::google::protobuf::int64 crawl_time() const;
  inline void set_crawl_time(::google::protobuf::int64 value);
  
  // required int32 ota_id = 3;
  inline bool has_ota_id() const;
  inline void clear_ota_id();
  static const int kOtaIdFieldNumber = 3;
  inline ::google::protobuf::int32 ota_id() const;
  inline void set_ota_id(::google::protobuf::int32 value);
  
  // optional .price.PriceInfo origin_price = 4;
  inline bool has_origin_price() const;
  inline void clear_origin_price();
  static const int kOriginPriceFieldNumber = 4;
  inline const ::price::PriceInfo& origin_price() const;
  inline ::price::PriceInfo* mutable_origin_price();
  inline ::price::PriceInfo* release_origin_price();
  
  // optional .price.PriceInfo sale_price = 5;
  inline bool has_sale_price() const;
  inline void clear_sale_price();
  static const int kSalePriceFieldNumber = 5;
  inline const ::price::PriceInfo& sale_price() const;
  inline ::price::PriceInfo* mutable_sale_price();
  inline ::price::PriceInfo* release_sale_price();
  
  // repeated .price.PromotionInfo promotion_info = 6;
  inline int promotion_info_size() const;
  inline void clear_promotion_info();
  static const int kPromotionInfoFieldNumber = 6;
  inline const ::price::PromotionInfo& promotion_info(int index) const;
  inline ::price::PromotionInfo* mutable_promotion_info(int index);
  inline ::price::PromotionInfo* add_promotion_info();
  inline const ::google::protobuf::RepeatedPtrField< ::price::PromotionInfo >&
      promotion_info() const;
  inline ::google::protobuf::RepeatedPtrField< ::price::PromotionInfo >*
      mutable_promotion_info();
  
  // optional .price.PayType pay_type = 7 [default = PRE_PAY];
  inline bool has_pay_type() const;
  inline void clear_pay_type();
  static const int kPayTypeFieldNumber = 7;
  inline price::PayType pay_type() const;
  inline void set_pay_type(price::PayType value);
  
  // @@protoc_insertion_point(class_scope:price.ListOta)
 private:
  inline void set_has_base_hotel_id();
  inline void clear_has_base_hotel_id();
  inline void set_has_crawl_time();
  inline void clear_has_crawl_time();
  inline void set_has_ota_id();
  inline void clear_has_ota_id();
  inline void set_has_origin_price();
  inline void clear_has_origin_price();
  inline void set_has_sale_price();
  inline void clear_has_sale_price();
  inline void set_has_pay_type();
  inline void clear_has_pay_type();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int64 crawl_time_;
  ::google::protobuf::int32 base_hotel_id_;
  ::google::protobuf::int32 ota_id_;
  ::price::PriceInfo* origin_price_;
  ::price::PriceInfo* sale_price_;
  ::google::protobuf::RepeatedPtrField< ::price::PromotionInfo > promotion_info_;
  int pay_type_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];
  
  friend void  protobuf_AddDesc_price_5ftypes_2eproto();
  friend void protobuf_AssignDesc_price_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_price_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static ListOta* default_instance_;
};
// -------------------------------------------------------------------

class ListHotel : public ::google::protobuf::Message {
 public:
  ListHotel();
  virtual ~ListHotel();
  
  ListHotel(const ListHotel& from);
  
  inline ListHotel& operator=(const ListHotel& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ListHotel& default_instance();
  
  void Swap(ListHotel* other);
  
  // implements Message ----------------------------------------------
  
  ListHotel* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ListHotel& from);
  void MergeFrom(const ListHotel& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 base_hotel_id = 1;
  inline bool has_base_hotel_id() const;
  inline void clear_base_hotel_id();
  static const int kBaseHotelIdFieldNumber = 1;
  inline ::google::protobuf::int32 base_hotel_id() const;
  inline void set_base_hotel_id(::google::protobuf::int32 value);
  
  // optional int64 crawl_time = 2;
  inline bool has_crawl_time() const;
  inline void clear_crawl_time();
  static const int kCrawlTimeFieldNumber = 2;
  inline ::google::protobuf::int64 crawl_time() const;
  inline void set_crawl_time(::google::protobuf::int64 value);
  
  // optional .price.BookingStatus booking_status = 4;
  inline bool has_booking_status() const;
  inline void clear_booking_status();
  static const int kBookingStatusFieldNumber = 4;
  inline price::BookingStatus booking_status() const;
  inline void set_booking_status(price::BookingStatus value);
  
  // repeated .price.PromotionInfo promotion_info = 5;
  inline int promotion_info_size() const;
  inline void clear_promotion_info();
  static const int kPromotionInfoFieldNumber = 5;
  inline const ::price::PromotionInfo& promotion_info(int index) const;
  inline ::price::PromotionInfo* mutable_promotion_info(int index);
  inline ::price::PromotionInfo* add_promotion_info();
  inline const ::google::protobuf::RepeatedPtrField< ::price::PromotionInfo >&
      promotion_info() const;
  inline ::google::protobuf::RepeatedPtrField< ::price::PromotionInfo >*
      mutable_promotion_info();
  
  // repeated .price.ListOta list_ota_list = 6;
  inline int list_ota_list_size() const;
  inline void clear_list_ota_list();
  static const int kListOtaListFieldNumber = 6;
  inline const ::price::ListOta& list_ota_list(int index) const;
  inline ::price::ListOta* mutable_list_ota_list(int index);
  inline ::price::ListOta* add_list_ota_list();
  inline const ::google::protobuf::RepeatedPtrField< ::price::ListOta >&
      list_ota_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::price::ListOta >*
      mutable_list_ota_list();
  
  // optional bool mobile_only = 7 [default = false];
  inline bool has_mobile_only() const;
  inline void clear_mobile_only();
  static const int kMobileOnlyFieldNumber = 7;
  inline bool mobile_only() const;
  inline void set_mobile_only(bool value);
  
  // repeated .price.Tag tag = 12;
  inline int tag_size() const;
  inline void clear_tag();
  static const int kTagFieldNumber = 12;
  inline const ::price::Tag& tag(int index) const;
  inline ::price::Tag* mutable_tag(int index);
  inline ::price::Tag* add_tag();
  inline const ::google::protobuf::RepeatedPtrField< ::price::Tag >&
      tag() const;
  inline ::google::protobuf::RepeatedPtrField< ::price::Tag >*
      mutable_tag();
  
  // @@protoc_insertion_point(class_scope:price.ListHotel)
 private:
  inline void set_has_base_hotel_id();
  inline void clear_has_base_hotel_id();
  inline void set_has_crawl_time();
  inline void clear_has_crawl_time();
  inline void set_has_booking_status();
  inline void clear_has_booking_status();
  inline void set_has_mobile_only();
  inline void clear_has_mobile_only();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int64 crawl_time_;
  ::google::protobuf::int32 base_hotel_id_;
  int booking_status_;
  ::google::protobuf::RepeatedPtrField< ::price::PromotionInfo > promotion_info_;
  ::google::protobuf::RepeatedPtrField< ::price::ListOta > list_ota_list_;
  ::google::protobuf::RepeatedPtrField< ::price::Tag > tag_;
  bool mobile_only_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];
  
  friend void  protobuf_AddDesc_price_5ftypes_2eproto();
  friend void protobuf_AssignDesc_price_5ftypes_2eproto();
  friend void protobuf_ShutdownFile_price_5ftypes_2eproto();
  
  void InitAsDefaultInstance();
  static ListHotel* default_instance_;
};
// ===================================================================


// ===================================================================

// UserInfo

// optional string user_ip = 1;
inline bool UserInfo::has_user_ip() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserInfo::set_has_user_ip() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserInfo::clear_has_user_ip() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserInfo::clear_user_ip() {
  if (user_ip_ != &::google::protobuf::internal::kEmptyString) {
    user_ip_->clear();
  }
  clear_has_user_ip();
}
inline const ::std::string& UserInfo::user_ip() const {
  return *user_ip_;
}
inline void UserInfo::set_user_ip(const ::std::string& value) {
  set_has_user_ip();
  if (user_ip_ == &::google::protobuf::internal::kEmptyString) {
    user_ip_ = new ::std::string;
  }
  user_ip_->assign(value);
}
inline void UserInfo::set_user_ip(const char* value) {
  set_has_user_ip();
  if (user_ip_ == &::google::protobuf::internal::kEmptyString) {
    user_ip_ = new ::std::string;
  }
  user_ip_->assign(value);
}
inline void UserInfo::set_user_ip(const char* value, size_t size) {
  set_has_user_ip();
  if (user_ip_ == &::google::protobuf::internal::kEmptyString) {
    user_ip_ = new ::std::string;
  }
  user_ip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserInfo::mutable_user_ip() {
  set_has_user_ip();
  if (user_ip_ == &::google::protobuf::internal::kEmptyString) {
    user_ip_ = new ::std::string;
  }
  return user_ip_;
}
inline ::std::string* UserInfo::release_user_ip() {
  clear_has_user_ip();
  if (user_ip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = user_ip_;
    user_ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string session_id = 2;
inline bool UserInfo::has_session_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserInfo::set_has_session_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserInfo::clear_has_session_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserInfo::clear_session_id() {
  if (session_id_ != &::google::protobuf::internal::kEmptyString) {
    session_id_->clear();
  }
  clear_has_session_id();
}
inline const ::std::string& UserInfo::session_id() const {
  return *session_id_;
}
inline void UserInfo::set_session_id(const ::std::string& value) {
  set_has_session_id();
  if (session_id_ == &::google::protobuf::internal::kEmptyString) {
    session_id_ = new ::std::string;
  }
  session_id_->assign(value);
}
inline void UserInfo::set_session_id(const char* value) {
  set_has_session_id();
  if (session_id_ == &::google::protobuf::internal::kEmptyString) {
    session_id_ = new ::std::string;
  }
  session_id_->assign(value);
}
inline void UserInfo::set_session_id(const char* value, size_t size) {
  set_has_session_id();
  if (session_id_ == &::google::protobuf::internal::kEmptyString) {
    session_id_ = new ::std::string;
  }
  session_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserInfo::mutable_session_id() {
  set_has_session_id();
  if (session_id_ == &::google::protobuf::internal::kEmptyString) {
    session_id_ = new ::std::string;
  }
  return session_id_;
}
inline ::std::string* UserInfo::release_session_id() {
  clear_has_session_id();
  if (session_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = session_id_;
    session_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string cookie_id = 3;
inline bool UserInfo::has_cookie_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UserInfo::set_has_cookie_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UserInfo::clear_has_cookie_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UserInfo::clear_cookie_id() {
  if (cookie_id_ != &::google::protobuf::internal::kEmptyString) {
    cookie_id_->clear();
  }
  clear_has_cookie_id();
}
inline const ::std::string& UserInfo::cookie_id() const {
  return *cookie_id_;
}
inline void UserInfo::set_cookie_id(const ::std::string& value) {
  set_has_cookie_id();
  if (cookie_id_ == &::google::protobuf::internal::kEmptyString) {
    cookie_id_ = new ::std::string;
  }
  cookie_id_->assign(value);
}
inline void UserInfo::set_cookie_id(const char* value) {
  set_has_cookie_id();
  if (cookie_id_ == &::google::protobuf::internal::kEmptyString) {
    cookie_id_ = new ::std::string;
  }
  cookie_id_->assign(value);
}
inline void UserInfo::set_cookie_id(const char* value, size_t size) {
  set_has_cookie_id();
  if (cookie_id_ == &::google::protobuf::internal::kEmptyString) {
    cookie_id_ = new ::std::string;
  }
  cookie_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserInfo::mutable_cookie_id() {
  set_has_cookie_id();
  if (cookie_id_ == &::google::protobuf::internal::kEmptyString) {
    cookie_id_ = new ::std::string;
  }
  return cookie_id_;
}
inline ::std::string* UserInfo::release_cookie_id() {
  clear_has_cookie_id();
  if (cookie_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = cookie_id_;
    cookie_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string user_agent = 4;
inline bool UserInfo::has_user_agent() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UserInfo::set_has_user_agent() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UserInfo::clear_has_user_agent() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UserInfo::clear_user_agent() {
  if (user_agent_ != &::google::protobuf::internal::kEmptyString) {
    user_agent_->clear();
  }
  clear_has_user_agent();
}
inline const ::std::string& UserInfo::user_agent() const {
  return *user_agent_;
}
inline void UserInfo::set_user_agent(const ::std::string& value) {
  set_has_user_agent();
  if (user_agent_ == &::google::protobuf::internal::kEmptyString) {
    user_agent_ = new ::std::string;
  }
  user_agent_->assign(value);
}
inline void UserInfo::set_user_agent(const char* value) {
  set_has_user_agent();
  if (user_agent_ == &::google::protobuf::internal::kEmptyString) {
    user_agent_ = new ::std::string;
  }
  user_agent_->assign(value);
}
inline void UserInfo::set_user_agent(const char* value, size_t size) {
  set_has_user_agent();
  if (user_agent_ == &::google::protobuf::internal::kEmptyString) {
    user_agent_ = new ::std::string;
  }
  user_agent_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserInfo::mutable_user_agent() {
  set_has_user_agent();
  if (user_agent_ == &::google::protobuf::internal::kEmptyString) {
    user_agent_ = new ::std::string;
  }
  return user_agent_;
}
inline ::std::string* UserInfo::release_user_agent() {
  clear_has_user_agent();
  if (user_agent_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = user_agent_;
    user_agent_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 booking_channel = 5;
inline bool UserInfo::has_booking_channel() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void UserInfo::set_has_booking_channel() {
  _has_bits_[0] |= 0x00000010u;
}
inline void UserInfo::clear_has_booking_channel() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void UserInfo::clear_booking_channel() {
  booking_channel_ = 0;
  clear_has_booking_channel();
}
inline ::google::protobuf::int32 UserInfo::booking_channel() const {
  return booking_channel_;
}
inline void UserInfo::set_booking_channel(::google::protobuf::int32 value) {
  set_has_booking_channel();
  booking_channel_ = value;
}

// optional int32 order_from = 6;
inline bool UserInfo::has_order_from() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void UserInfo::set_has_order_from() {
  _has_bits_[0] |= 0x00000020u;
}
inline void UserInfo::clear_has_order_from() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void UserInfo::clear_order_from() {
  order_from_ = 0;
  clear_has_order_from();
}
inline ::google::protobuf::int32 UserInfo::order_from() const {
  return order_from_;
}
inline void UserInfo::set_order_from(::google::protobuf::int32 value) {
  set_has_order_from();
  order_from_ = value;
}

// optional int32 customer_level = 7;
inline bool UserInfo::has_customer_level() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void UserInfo::set_has_customer_level() {
  _has_bits_[0] |= 0x00000040u;
}
inline void UserInfo::clear_has_customer_level() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void UserInfo::clear_customer_level() {
  customer_level_ = 0;
  clear_has_customer_level();
}
inline ::google::protobuf::int32 UserInfo::customer_level() const {
  return customer_level_;
}
inline void UserInfo::set_customer_level(::google::protobuf::int32 value) {
  set_has_customer_level();
  customer_level_ = value;
}

// repeated int32 activity_id_list = 8;
inline int UserInfo::activity_id_list_size() const {
  return activity_id_list_.size();
}
inline void UserInfo::clear_activity_id_list() {
  activity_id_list_.Clear();
}
inline ::google::protobuf::int32 UserInfo::activity_id_list(int index) const {
  return activity_id_list_.Get(index);
}
inline void UserInfo::set_activity_id_list(int index, ::google::protobuf::int32 value) {
  activity_id_list_.Set(index, value);
}
inline void UserInfo::add_activity_id_list(::google::protobuf::int32 value) {
  activity_id_list_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
UserInfo::activity_id_list() const {
  return activity_id_list_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
UserInfo::mutable_activity_id_list() {
  return &activity_id_list_;
}

// optional string user_id = 9;
inline bool UserInfo::has_user_id() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void UserInfo::set_has_user_id() {
  _has_bits_[0] |= 0x00000100u;
}
inline void UserInfo::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void UserInfo::clear_user_id() {
  if (user_id_ != &::google::protobuf::internal::kEmptyString) {
    user_id_->clear();
  }
  clear_has_user_id();
}
inline const ::std::string& UserInfo::user_id() const {
  return *user_id_;
}
inline void UserInfo::set_user_id(const ::std::string& value) {
  set_has_user_id();
  if (user_id_ == &::google::protobuf::internal::kEmptyString) {
    user_id_ = new ::std::string;
  }
  user_id_->assign(value);
}
inline void UserInfo::set_user_id(const char* value) {
  set_has_user_id();
  if (user_id_ == &::google::protobuf::internal::kEmptyString) {
    user_id_ = new ::std::string;
  }
  user_id_->assign(value);
}
inline void UserInfo::set_user_id(const char* value, size_t size) {
  set_has_user_id();
  if (user_id_ == &::google::protobuf::internal::kEmptyString) {
    user_id_ = new ::std::string;
  }
  user_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserInfo::mutable_user_id() {
  set_has_user_id();
  if (user_id_ == &::google::protobuf::internal::kEmptyString) {
    user_id_ = new ::std::string;
  }
  return user_id_;
}
inline ::std::string* UserInfo::release_user_id() {
  clear_has_user_id();
  if (user_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = user_id_;
    user_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string device_id = 10;
inline bool UserInfo::has_device_id() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void UserInfo::set_has_device_id() {
  _has_bits_[0] |= 0x00000200u;
}
inline void UserInfo::clear_has_device_id() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void UserInfo::clear_device_id() {
  if (device_id_ != &::google::protobuf::internal::kEmptyString) {
    device_id_->clear();
  }
  clear_has_device_id();
}
inline const ::std::string& UserInfo::device_id() const {
  return *device_id_;
}
inline void UserInfo::set_device_id(const ::std::string& value) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(value);
}
inline void UserInfo::set_device_id(const char* value) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(value);
}
inline void UserInfo::set_device_id(const char* value, size_t size) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserInfo::mutable_device_id() {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  return device_id_;
}
inline ::std::string* UserInfo::release_device_id() {
  clear_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = device_id_;
    device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// CreditCard

// optional string ota_bankcode = 1;
inline bool CreditCard::has_ota_bankcode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CreditCard::set_has_ota_bankcode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CreditCard::clear_has_ota_bankcode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CreditCard::clear_ota_bankcode() {
  if (ota_bankcode_ != &::google::protobuf::internal::kEmptyString) {
    ota_bankcode_->clear();
  }
  clear_has_ota_bankcode();
}
inline const ::std::string& CreditCard::ota_bankcode() const {
  return *ota_bankcode_;
}
inline void CreditCard::set_ota_bankcode(const ::std::string& value) {
  set_has_ota_bankcode();
  if (ota_bankcode_ == &::google::protobuf::internal::kEmptyString) {
    ota_bankcode_ = new ::std::string;
  }
  ota_bankcode_->assign(value);
}
inline void CreditCard::set_ota_bankcode(const char* value) {
  set_has_ota_bankcode();
  if (ota_bankcode_ == &::google::protobuf::internal::kEmptyString) {
    ota_bankcode_ = new ::std::string;
  }
  ota_bankcode_->assign(value);
}
inline void CreditCard::set_ota_bankcode(const char* value, size_t size) {
  set_has_ota_bankcode();
  if (ota_bankcode_ == &::google::protobuf::internal::kEmptyString) {
    ota_bankcode_ = new ::std::string;
  }
  ota_bankcode_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CreditCard::mutable_ota_bankcode() {
  set_has_ota_bankcode();
  if (ota_bankcode_ == &::google::protobuf::internal::kEmptyString) {
    ota_bankcode_ = new ::std::string;
  }
  return ota_bankcode_;
}
inline ::std::string* CreditCard::release_ota_bankcode() {
  clear_has_ota_bankcode();
  if (ota_bankcode_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ota_bankcode_;
    ota_bankcode_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string elong_bankcode = 2;
inline bool CreditCard::has_elong_bankcode() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CreditCard::set_has_elong_bankcode() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CreditCard::clear_has_elong_bankcode() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CreditCard::clear_elong_bankcode() {
  if (elong_bankcode_ != &::google::protobuf::internal::kEmptyString) {
    elong_bankcode_->clear();
  }
  clear_has_elong_bankcode();
}
inline const ::std::string& CreditCard::elong_bankcode() const {
  return *elong_bankcode_;
}
inline void CreditCard::set_elong_bankcode(const ::std::string& value) {
  set_has_elong_bankcode();
  if (elong_bankcode_ == &::google::protobuf::internal::kEmptyString) {
    elong_bankcode_ = new ::std::string;
  }
  elong_bankcode_->assign(value);
}
inline void CreditCard::set_elong_bankcode(const char* value) {
  set_has_elong_bankcode();
  if (elong_bankcode_ == &::google::protobuf::internal::kEmptyString) {
    elong_bankcode_ = new ::std::string;
  }
  elong_bankcode_->assign(value);
}
inline void CreditCard::set_elong_bankcode(const char* value, size_t size) {
  set_has_elong_bankcode();
  if (elong_bankcode_ == &::google::protobuf::internal::kEmptyString) {
    elong_bankcode_ = new ::std::string;
  }
  elong_bankcode_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CreditCard::mutable_elong_bankcode() {
  set_has_elong_bankcode();
  if (elong_bankcode_ == &::google::protobuf::internal::kEmptyString) {
    elong_bankcode_ = new ::std::string;
  }
  return elong_bankcode_;
}
inline ::std::string* CreditCard::release_elong_bankcode() {
  clear_has_elong_bankcode();
  if (elong_bankcode_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = elong_bankcode_;
    elong_bankcode_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bytes card_desc = 3;
inline bool CreditCard::has_card_desc() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CreditCard::set_has_card_desc() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CreditCard::clear_has_card_desc() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CreditCard::clear_card_desc() {
  if (card_desc_ != &::google::protobuf::internal::kEmptyString) {
    card_desc_->clear();
  }
  clear_has_card_desc();
}
inline const ::std::string& CreditCard::card_desc() const {
  return *card_desc_;
}
inline void CreditCard::set_card_desc(const ::std::string& value) {
  set_has_card_desc();
  if (card_desc_ == &::google::protobuf::internal::kEmptyString) {
    card_desc_ = new ::std::string;
  }
  card_desc_->assign(value);
}
inline void CreditCard::set_card_desc(const char* value) {
  set_has_card_desc();
  if (card_desc_ == &::google::protobuf::internal::kEmptyString) {
    card_desc_ = new ::std::string;
  }
  card_desc_->assign(value);
}
inline void CreditCard::set_card_desc(const void* value, size_t size) {
  set_has_card_desc();
  if (card_desc_ == &::google::protobuf::internal::kEmptyString) {
    card_desc_ = new ::std::string;
  }
  card_desc_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CreditCard::mutable_card_desc() {
  set_has_card_desc();
  if (card_desc_ == &::google::protobuf::internal::kEmptyString) {
    card_desc_ = new ::std::string;
  }
  return card_desc_;
}
inline ::std::string* CreditCard::release_card_desc() {
  clear_has_card_desc();
  if (card_desc_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = card_desc_;
    card_desc_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// GuaranteeAndDeposit

// optional bool cc_required = 1 [default = false];
inline bool GuaranteeAndDeposit::has_cc_required() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GuaranteeAndDeposit::set_has_cc_required() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GuaranteeAndDeposit::clear_has_cc_required() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GuaranteeAndDeposit::clear_cc_required() {
  cc_required_ = false;
  clear_has_cc_required();
}
inline bool GuaranteeAndDeposit::cc_required() const {
  return cc_required_;
}
inline void GuaranteeAndDeposit::set_cc_required(bool value) {
  set_has_cc_required();
  cc_required_ = value;
}

// optional bool cvc_required = 2 [default = false];
inline bool GuaranteeAndDeposit::has_cvc_required() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GuaranteeAndDeposit::set_has_cvc_required() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GuaranteeAndDeposit::clear_has_cvc_required() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GuaranteeAndDeposit::clear_cvc_required() {
  cvc_required_ = false;
  clear_has_cvc_required();
}
inline bool GuaranteeAndDeposit::cvc_required() const {
  return cvc_required_;
}
inline void GuaranteeAndDeposit::set_cvc_required(bool value) {
  set_has_cvc_required();
  cvc_required_ = value;
}

// optional bool guarantee_required = 3 [default = false];
inline bool GuaranteeAndDeposit::has_guarantee_required() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GuaranteeAndDeposit::set_has_guarantee_required() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GuaranteeAndDeposit::clear_has_guarantee_required() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GuaranteeAndDeposit::clear_guarantee_required() {
  guarantee_required_ = false;
  clear_has_guarantee_required();
}
inline bool GuaranteeAndDeposit::guarantee_required() const {
  return guarantee_required_;
}
inline void GuaranteeAndDeposit::set_guarantee_required(bool value) {
  set_has_guarantee_required();
  guarantee_required_ = value;
}

// optional .price.PriceItem guarantee_amount = 4;
inline bool GuaranteeAndDeposit::has_guarantee_amount() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GuaranteeAndDeposit::set_has_guarantee_amount() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GuaranteeAndDeposit::clear_has_guarantee_amount() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GuaranteeAndDeposit::clear_guarantee_amount() {
  if (guarantee_amount_ != NULL) guarantee_amount_->::price::PriceItem::Clear();
  clear_has_guarantee_amount();
}
inline const ::price::PriceItem& GuaranteeAndDeposit::guarantee_amount() const {
  return guarantee_amount_ != NULL ? *guarantee_amount_ : *default_instance_->guarantee_amount_;
}
inline ::price::PriceItem* GuaranteeAndDeposit::mutable_guarantee_amount() {
  set_has_guarantee_amount();
  if (guarantee_amount_ == NULL) guarantee_amount_ = new ::price::PriceItem;
  return guarantee_amount_;
}
inline ::price::PriceItem* GuaranteeAndDeposit::release_guarantee_amount() {
  clear_has_guarantee_amount();
  ::price::PriceItem* temp = guarantee_amount_;
  guarantee_amount_ = NULL;
  return temp;
}

// optional bool deposit_required = 5 [default = false];
inline bool GuaranteeAndDeposit::has_deposit_required() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GuaranteeAndDeposit::set_has_deposit_required() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GuaranteeAndDeposit::clear_has_deposit_required() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GuaranteeAndDeposit::clear_deposit_required() {
  deposit_required_ = false;
  clear_has_deposit_required();
}
inline bool GuaranteeAndDeposit::deposit_required() const {
  return deposit_required_;
}
inline void GuaranteeAndDeposit::set_deposit_required(bool value) {
  set_has_deposit_required();
  deposit_required_ = value;
}

// optional .price.PriceItem deposit_amount = 6;
inline bool GuaranteeAndDeposit::has_deposit_amount() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void GuaranteeAndDeposit::set_has_deposit_amount() {
  _has_bits_[0] |= 0x00000020u;
}
inline void GuaranteeAndDeposit::clear_has_deposit_amount() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void GuaranteeAndDeposit::clear_deposit_amount() {
  if (deposit_amount_ != NULL) deposit_amount_->::price::PriceItem::Clear();
  clear_has_deposit_amount();
}
inline const ::price::PriceItem& GuaranteeAndDeposit::deposit_amount() const {
  return deposit_amount_ != NULL ? *deposit_amount_ : *default_instance_->deposit_amount_;
}
inline ::price::PriceItem* GuaranteeAndDeposit::mutable_deposit_amount() {
  set_has_deposit_amount();
  if (deposit_amount_ == NULL) deposit_amount_ = new ::price::PriceItem;
  return deposit_amount_;
}
inline ::price::PriceItem* GuaranteeAndDeposit::release_deposit_amount() {
  clear_has_deposit_amount();
  ::price::PriceItem* temp = deposit_amount_;
  deposit_amount_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// PromotionInfo

// optional .price.PromotionType type = 1;
inline bool PromotionInfo::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PromotionInfo::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PromotionInfo::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PromotionInfo::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline price::PromotionType PromotionInfo::type() const {
  return static_cast< price::PromotionType >(type_);
}
inline void PromotionInfo::set_type(price::PromotionType value) {
  GOOGLE_DCHECK(price::PromotionType_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional string value = 2;
inline bool PromotionInfo::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PromotionInfo::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PromotionInfo::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PromotionInfo::clear_value() {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    value_->clear();
  }
  clear_has_value();
}
inline const ::std::string& PromotionInfo::value() const {
  return *value_;
}
inline void PromotionInfo::set_value(const ::std::string& value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void PromotionInfo::set_value(const char* value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void PromotionInfo::set_value(const char* value, size_t size) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PromotionInfo::mutable_value() {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  return value_;
}
inline ::std::string* PromotionInfo::release_value() {
  clear_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = value_;
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// Tag

// optional .price.TagType type = 1;
inline bool Tag::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Tag::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Tag::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Tag::clear_type() {
  type_ = 101;
  clear_has_type();
}
inline price::TagType Tag::type() const {
  return static_cast< price::TagType >(type_);
}
inline void Tag::set_type(price::TagType value) {
  GOOGLE_DCHECK(price::TagType_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional string value = 2;
inline bool Tag::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Tag::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Tag::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Tag::clear_value() {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    value_->clear();
  }
  clear_has_value();
}
inline const ::std::string& Tag::value() const {
  return *value_;
}
inline void Tag::set_value(const ::std::string& value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void Tag::set_value(const char* value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void Tag::set_value(const char* value, size_t size) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Tag::mutable_value() {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  return value_;
}
inline ::std::string* Tag::release_value() {
  clear_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = value_;
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// CancellationInfo

// optional string start_date = 1;
inline bool CancellationInfo::has_start_date() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CancellationInfo::set_has_start_date() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CancellationInfo::clear_has_start_date() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CancellationInfo::clear_start_date() {
  if (start_date_ != &::google::protobuf::internal::kEmptyString) {
    start_date_->clear();
  }
  clear_has_start_date();
}
inline const ::std::string& CancellationInfo::start_date() const {
  return *start_date_;
}
inline void CancellationInfo::set_start_date(const ::std::string& value) {
  set_has_start_date();
  if (start_date_ == &::google::protobuf::internal::kEmptyString) {
    start_date_ = new ::std::string;
  }
  start_date_->assign(value);
}
inline void CancellationInfo::set_start_date(const char* value) {
  set_has_start_date();
  if (start_date_ == &::google::protobuf::internal::kEmptyString) {
    start_date_ = new ::std::string;
  }
  start_date_->assign(value);
}
inline void CancellationInfo::set_start_date(const char* value, size_t size) {
  set_has_start_date();
  if (start_date_ == &::google::protobuf::internal::kEmptyString) {
    start_date_ = new ::std::string;
  }
  start_date_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CancellationInfo::mutable_start_date() {
  set_has_start_date();
  if (start_date_ == &::google::protobuf::internal::kEmptyString) {
    start_date_ = new ::std::string;
  }
  return start_date_;
}
inline ::std::string* CancellationInfo::release_start_date() {
  clear_has_start_date();
  if (start_date_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = start_date_;
    start_date_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string local_start_date = 2;
inline bool CancellationInfo::has_local_start_date() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CancellationInfo::set_has_local_start_date() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CancellationInfo::clear_has_local_start_date() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CancellationInfo::clear_local_start_date() {
  if (local_start_date_ != &::google::protobuf::internal::kEmptyString) {
    local_start_date_->clear();
  }
  clear_has_local_start_date();
}
inline const ::std::string& CancellationInfo::local_start_date() const {
  return *local_start_date_;
}
inline void CancellationInfo::set_local_start_date(const ::std::string& value) {
  set_has_local_start_date();
  if (local_start_date_ == &::google::protobuf::internal::kEmptyString) {
    local_start_date_ = new ::std::string;
  }
  local_start_date_->assign(value);
}
inline void CancellationInfo::set_local_start_date(const char* value) {
  set_has_local_start_date();
  if (local_start_date_ == &::google::protobuf::internal::kEmptyString) {
    local_start_date_ = new ::std::string;
  }
  local_start_date_->assign(value);
}
inline void CancellationInfo::set_local_start_date(const char* value, size_t size) {
  set_has_local_start_date();
  if (local_start_date_ == &::google::protobuf::internal::kEmptyString) {
    local_start_date_ = new ::std::string;
  }
  local_start_date_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CancellationInfo::mutable_local_start_date() {
  set_has_local_start_date();
  if (local_start_date_ == &::google::protobuf::internal::kEmptyString) {
    local_start_date_ = new ::std::string;
  }
  return local_start_date_;
}
inline ::std::string* CancellationInfo::release_local_start_date() {
  clear_has_local_start_date();
  if (local_start_date_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = local_start_date_;
    local_start_date_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string end_date = 3;
inline bool CancellationInfo::has_end_date() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CancellationInfo::set_has_end_date() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CancellationInfo::clear_has_end_date() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CancellationInfo::clear_end_date() {
  if (end_date_ != &::google::protobuf::internal::kEmptyString) {
    end_date_->clear();
  }
  clear_has_end_date();
}
inline const ::std::string& CancellationInfo::end_date() const {
  return *end_date_;
}
inline void CancellationInfo::set_end_date(const ::std::string& value) {
  set_has_end_date();
  if (end_date_ == &::google::protobuf::internal::kEmptyString) {
    end_date_ = new ::std::string;
  }
  end_date_->assign(value);
}
inline void CancellationInfo::set_end_date(const char* value) {
  set_has_end_date();
  if (end_date_ == &::google::protobuf::internal::kEmptyString) {
    end_date_ = new ::std::string;
  }
  end_date_->assign(value);
}
inline void CancellationInfo::set_end_date(const char* value, size_t size) {
  set_has_end_date();
  if (end_date_ == &::google::protobuf::internal::kEmptyString) {
    end_date_ = new ::std::string;
  }
  end_date_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CancellationInfo::mutable_end_date() {
  set_has_end_date();
  if (end_date_ == &::google::protobuf::internal::kEmptyString) {
    end_date_ = new ::std::string;
  }
  return end_date_;
}
inline ::std::string* CancellationInfo::release_end_date() {
  clear_has_end_date();
  if (end_date_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = end_date_;
    end_date_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string local_end_date = 4;
inline bool CancellationInfo::has_local_end_date() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CancellationInfo::set_has_local_end_date() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CancellationInfo::clear_has_local_end_date() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CancellationInfo::clear_local_end_date() {
  if (local_end_date_ != &::google::protobuf::internal::kEmptyString) {
    local_end_date_->clear();
  }
  clear_has_local_end_date();
}
inline const ::std::string& CancellationInfo::local_end_date() const {
  return *local_end_date_;
}
inline void CancellationInfo::set_local_end_date(const ::std::string& value) {
  set_has_local_end_date();
  if (local_end_date_ == &::google::protobuf::internal::kEmptyString) {
    local_end_date_ = new ::std::string;
  }
  local_end_date_->assign(value);
}
inline void CancellationInfo::set_local_end_date(const char* value) {
  set_has_local_end_date();
  if (local_end_date_ == &::google::protobuf::internal::kEmptyString) {
    local_end_date_ = new ::std::string;
  }
  local_end_date_->assign(value);
}
inline void CancellationInfo::set_local_end_date(const char* value, size_t size) {
  set_has_local_end_date();
  if (local_end_date_ == &::google::protobuf::internal::kEmptyString) {
    local_end_date_ = new ::std::string;
  }
  local_end_date_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CancellationInfo::mutable_local_end_date() {
  set_has_local_end_date();
  if (local_end_date_ == &::google::protobuf::internal::kEmptyString) {
    local_end_date_ = new ::std::string;
  }
  return local_end_date_;
}
inline ::std::string* CancellationInfo::release_local_end_date() {
  clear_has_local_end_date();
  if (local_end_date_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = local_end_date_;
    local_end_date_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string refundable = 5;
inline bool CancellationInfo::has_refundable() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CancellationInfo::set_has_refundable() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CancellationInfo::clear_has_refundable() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CancellationInfo::clear_refundable() {
  if (refundable_ != &::google::protobuf::internal::kEmptyString) {
    refundable_->clear();
  }
  clear_has_refundable();
}
inline const ::std::string& CancellationInfo::refundable() const {
  return *refundable_;
}
inline void CancellationInfo::set_refundable(const ::std::string& value) {
  set_has_refundable();
  if (refundable_ == &::google::protobuf::internal::kEmptyString) {
    refundable_ = new ::std::string;
  }
  refundable_->assign(value);
}
inline void CancellationInfo::set_refundable(const char* value) {
  set_has_refundable();
  if (refundable_ == &::google::protobuf::internal::kEmptyString) {
    refundable_ = new ::std::string;
  }
  refundable_->assign(value);
}
inline void CancellationInfo::set_refundable(const char* value, size_t size) {
  set_has_refundable();
  if (refundable_ == &::google::protobuf::internal::kEmptyString) {
    refundable_ = new ::std::string;
  }
  refundable_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CancellationInfo::mutable_refundable() {
  set_has_refundable();
  if (refundable_ == &::google::protobuf::internal::kEmptyString) {
    refundable_ = new ::std::string;
  }
  return refundable_;
}
inline ::std::string* CancellationInfo::release_refundable() {
  clear_has_refundable();
  if (refundable_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = refundable_;
    refundable_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional .price.PriceItem customer_price = 6;
inline bool CancellationInfo::has_customer_price() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CancellationInfo::set_has_customer_price() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CancellationInfo::clear_has_customer_price() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CancellationInfo::clear_customer_price() {
  if (customer_price_ != NULL) customer_price_->::price::PriceItem::Clear();
  clear_has_customer_price();
}
inline const ::price::PriceItem& CancellationInfo::customer_price() const {
  return customer_price_ != NULL ? *customer_price_ : *default_instance_->customer_price_;
}
inline ::price::PriceItem* CancellationInfo::mutable_customer_price() {
  set_has_customer_price();
  if (customer_price_ == NULL) customer_price_ = new ::price::PriceItem;
  return customer_price_;
}
inline ::price::PriceItem* CancellationInfo::release_customer_price() {
  clear_has_customer_price();
  ::price::PriceItem* temp = customer_price_;
  customer_price_ = NULL;
  return temp;
}

// optional .price.PriceItem supplier_price = 7;
inline bool CancellationInfo::has_supplier_price() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CancellationInfo::set_has_supplier_price() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CancellationInfo::clear_has_supplier_price() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CancellationInfo::clear_supplier_price() {
  if (supplier_price_ != NULL) supplier_price_->::price::PriceItem::Clear();
  clear_has_supplier_price();
}
inline const ::price::PriceItem& CancellationInfo::supplier_price() const {
  return supplier_price_ != NULL ? *supplier_price_ : *default_instance_->supplier_price_;
}
inline ::price::PriceItem* CancellationInfo::mutable_supplier_price() {
  set_has_supplier_price();
  if (supplier_price_ == NULL) supplier_price_ = new ::price::PriceItem;
  return supplier_price_;
}
inline ::price::PriceItem* CancellationInfo::release_supplier_price() {
  clear_has_supplier_price();
  ::price::PriceItem* temp = supplier_price_;
  supplier_price_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// PriceItem

// required int64 amount = 1;
inline bool PriceItem::has_amount() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PriceItem::set_has_amount() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PriceItem::clear_has_amount() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PriceItem::clear_amount() {
  amount_ = GOOGLE_LONGLONG(0);
  clear_has_amount();
}
inline ::google::protobuf::int64 PriceItem::amount() const {
  return amount_;
}
inline void PriceItem::set_amount(::google::protobuf::int64 value) {
  set_has_amount();
  amount_ = value;
}

// required string currency = 2 [default = "CNY"];
inline bool PriceItem::has_currency() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PriceItem::set_has_currency() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PriceItem::clear_has_currency() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PriceItem::clear_currency() {
  if (currency_ != &_default_currency_) {
    currency_->assign(_default_currency_);
  }
  clear_has_currency();
}
inline const ::std::string& PriceItem::currency() const {
  return *currency_;
}
inline void PriceItem::set_currency(const ::std::string& value) {
  set_has_currency();
  if (currency_ == &_default_currency_) {
    currency_ = new ::std::string;
  }
  currency_->assign(value);
}
inline void PriceItem::set_currency(const char* value) {
  set_has_currency();
  if (currency_ == &_default_currency_) {
    currency_ = new ::std::string;
  }
  currency_->assign(value);
}
inline void PriceItem::set_currency(const char* value, size_t size) {
  set_has_currency();
  if (currency_ == &_default_currency_) {
    currency_ = new ::std::string;
  }
  currency_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PriceItem::mutable_currency() {
  set_has_currency();
  if (currency_ == &_default_currency_) {
    currency_ = new ::std::string(_default_currency_);
  }
  return currency_;
}
inline ::std::string* PriceItem::release_currency() {
  clear_has_currency();
  if (currency_ == &_default_currency_) {
    return NULL;
  } else {
    ::std::string* temp = currency_;
    currency_ = const_cast< ::std::string*>(&_default_currency_);
    return temp;
  }
}

// optional double currency_rate = 3 [default = 1];
inline bool PriceItem::has_currency_rate() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PriceItem::set_has_currency_rate() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PriceItem::clear_has_currency_rate() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PriceItem::clear_currency_rate() {
  currency_rate_ = 1;
  clear_has_currency_rate();
}
inline double PriceItem::currency_rate() const {
  return currency_rate_;
}
inline void PriceItem::set_currency_rate(double value) {
  set_has_currency_rate();
  currency_rate_ = value;
}

// -------------------------------------------------------------------

// DailyPrice

// optional string date = 1;
inline bool DailyPrice::has_date() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DailyPrice::set_has_date() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DailyPrice::clear_has_date() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DailyPrice::clear_date() {
  if (date_ != &::google::protobuf::internal::kEmptyString) {
    date_->clear();
  }
  clear_has_date();
}
inline const ::std::string& DailyPrice::date() const {
  return *date_;
}
inline void DailyPrice::set_date(const ::std::string& value) {
  set_has_date();
  if (date_ == &::google::protobuf::internal::kEmptyString) {
    date_ = new ::std::string;
  }
  date_->assign(value);
}
inline void DailyPrice::set_date(const char* value) {
  set_has_date();
  if (date_ == &::google::protobuf::internal::kEmptyString) {
    date_ = new ::std::string;
  }
  date_->assign(value);
}
inline void DailyPrice::set_date(const char* value, size_t size) {
  set_has_date();
  if (date_ == &::google::protobuf::internal::kEmptyString) {
    date_ = new ::std::string;
  }
  date_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DailyPrice::mutable_date() {
  set_has_date();
  if (date_ == &::google::protobuf::internal::kEmptyString) {
    date_ = new ::std::string;
  }
  return date_;
}
inline ::std::string* DailyPrice::release_date() {
  clear_has_date();
  if (date_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = date_;
    date_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional .price.PriceItem price = 2;
inline bool DailyPrice::has_price() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DailyPrice::set_has_price() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DailyPrice::clear_has_price() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DailyPrice::clear_price() {
  if (price_ != NULL) price_->::price::PriceItem::Clear();
  clear_has_price();
}
inline const ::price::PriceItem& DailyPrice::price() const {
  return price_ != NULL ? *price_ : *default_instance_->price_;
}
inline ::price::PriceItem* DailyPrice::mutable_price() {
  set_has_price();
  if (price_ == NULL) price_ = new ::price::PriceItem;
  return price_;
}
inline ::price::PriceItem* DailyPrice::release_price() {
  clear_has_price();
  ::price::PriceItem* temp = price_;
  price_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// BedType

// required string id = 1;
inline bool BedType::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BedType::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BedType::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BedType::clear_id() {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& BedType::id() const {
  return *id_;
}
inline void BedType::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void BedType::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void BedType::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BedType::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  return id_;
}
inline ::std::string* BedType::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required bytes bed_name_cn = 2;
inline bool BedType::has_bed_name_cn() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BedType::set_has_bed_name_cn() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BedType::clear_has_bed_name_cn() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BedType::clear_bed_name_cn() {
  if (bed_name_cn_ != &::google::protobuf::internal::kEmptyString) {
    bed_name_cn_->clear();
  }
  clear_has_bed_name_cn();
}
inline const ::std::string& BedType::bed_name_cn() const {
  return *bed_name_cn_;
}
inline void BedType::set_bed_name_cn(const ::std::string& value) {
  set_has_bed_name_cn();
  if (bed_name_cn_ == &::google::protobuf::internal::kEmptyString) {
    bed_name_cn_ = new ::std::string;
  }
  bed_name_cn_->assign(value);
}
inline void BedType::set_bed_name_cn(const char* value) {
  set_has_bed_name_cn();
  if (bed_name_cn_ == &::google::protobuf::internal::kEmptyString) {
    bed_name_cn_ = new ::std::string;
  }
  bed_name_cn_->assign(value);
}
inline void BedType::set_bed_name_cn(const void* value, size_t size) {
  set_has_bed_name_cn();
  if (bed_name_cn_ == &::google::protobuf::internal::kEmptyString) {
    bed_name_cn_ = new ::std::string;
  }
  bed_name_cn_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BedType::mutable_bed_name_cn() {
  set_has_bed_name_cn();
  if (bed_name_cn_ == &::google::protobuf::internal::kEmptyString) {
    bed_name_cn_ = new ::std::string;
  }
  return bed_name_cn_;
}
inline ::std::string* BedType::release_bed_name_cn() {
  clear_has_bed_name_cn();
  if (bed_name_cn_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = bed_name_cn_;
    bed_name_cn_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bytes bed_name_en = 3;
inline bool BedType::has_bed_name_en() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BedType::set_has_bed_name_en() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BedType::clear_has_bed_name_en() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BedType::clear_bed_name_en() {
  if (bed_name_en_ != &::google::protobuf::internal::kEmptyString) {
    bed_name_en_->clear();
  }
  clear_has_bed_name_en();
}
inline const ::std::string& BedType::bed_name_en() const {
  return *bed_name_en_;
}
inline void BedType::set_bed_name_en(const ::std::string& value) {
  set_has_bed_name_en();
  if (bed_name_en_ == &::google::protobuf::internal::kEmptyString) {
    bed_name_en_ = new ::std::string;
  }
  bed_name_en_->assign(value);
}
inline void BedType::set_bed_name_en(const char* value) {
  set_has_bed_name_en();
  if (bed_name_en_ == &::google::protobuf::internal::kEmptyString) {
    bed_name_en_ = new ::std::string;
  }
  bed_name_en_->assign(value);
}
inline void BedType::set_bed_name_en(const void* value, size_t size) {
  set_has_bed_name_en();
  if (bed_name_en_ == &::google::protobuf::internal::kEmptyString) {
    bed_name_en_ = new ::std::string;
  }
  bed_name_en_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BedType::mutable_bed_name_en() {
  set_has_bed_name_en();
  if (bed_name_en_ == &::google::protobuf::internal::kEmptyString) {
    bed_name_en_ = new ::std::string;
  }
  return bed_name_en_;
}
inline ::std::string* BedType::release_bed_name_en() {
  clear_has_bed_name_en();
  if (bed_name_en_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = bed_name_en_;
    bed_name_en_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 num = 4;
inline bool BedType::has_num() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BedType::set_has_num() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BedType::clear_has_num() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BedType::clear_num() {
  num_ = 0;
  clear_has_num();
}
inline ::google::protobuf::int32 BedType::num() const {
  return num_;
}
inline void BedType::set_num(::google::protobuf::int32 value) {
  set_has_num();
  num_ = value;
}

// optional bytes size = 5;
inline bool BedType::has_size() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void BedType::set_has_size() {
  _has_bits_[0] |= 0x00000010u;
}
inline void BedType::clear_has_size() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void BedType::clear_size() {
  if (size_ != &::google::protobuf::internal::kEmptyString) {
    size_->clear();
  }
  clear_has_size();
}
inline const ::std::string& BedType::size() const {
  return *size_;
}
inline void BedType::set_size(const ::std::string& value) {
  set_has_size();
  if (size_ == &::google::protobuf::internal::kEmptyString) {
    size_ = new ::std::string;
  }
  size_->assign(value);
}
inline void BedType::set_size(const char* value) {
  set_has_size();
  if (size_ == &::google::protobuf::internal::kEmptyString) {
    size_ = new ::std::string;
  }
  size_->assign(value);
}
inline void BedType::set_size(const void* value, size_t size) {
  set_has_size();
  if (size_ == &::google::protobuf::internal::kEmptyString) {
    size_ = new ::std::string;
  }
  size_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BedType::mutable_size() {
  set_has_size();
  if (size_ == &::google::protobuf::internal::kEmptyString) {
    size_ = new ::std::string;
  }
  return size_;
}
inline ::std::string* BedType::release_size() {
  clear_has_size();
  if (size_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = size_;
    size_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bool is_ambiguous = 6 [default = true];
inline bool BedType::has_is_ambiguous() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void BedType::set_has_is_ambiguous() {
  _has_bits_[0] |= 0x00000020u;
}
inline void BedType::clear_has_is_ambiguous() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void BedType::clear_is_ambiguous() {
  is_ambiguous_ = true;
  clear_has_is_ambiguous();
}
inline bool BedType::is_ambiguous() const {
  return is_ambiguous_;
}
inline void BedType::set_is_ambiguous(bool value) {
  set_has_is_ambiguous();
  is_ambiguous_ = value;
}

// -------------------------------------------------------------------

// BedGroup

// repeated .price.BedType bed_type_list = 1;
inline int BedGroup::bed_type_list_size() const {
  return bed_type_list_.size();
}
inline void BedGroup::clear_bed_type_list() {
  bed_type_list_.Clear();
}
inline const ::price::BedType& BedGroup::bed_type_list(int index) const {
  return bed_type_list_.Get(index);
}
inline ::price::BedType* BedGroup::mutable_bed_type_list(int index) {
  return bed_type_list_.Mutable(index);
}
inline ::price::BedType* BedGroup::add_bed_type_list() {
  return bed_type_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::price::BedType >&
BedGroup::bed_type_list() const {
  return bed_type_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::price::BedType >*
BedGroup::mutable_bed_type_list() {
  return &bed_type_list_;
}

// -------------------------------------------------------------------

// ChargePrice

// required .price.PriceItem price = 1;
inline bool ChargePrice::has_price() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ChargePrice::set_has_price() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ChargePrice::clear_has_price() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ChargePrice::clear_price() {
  if (price_ != NULL) price_->::price::PriceItem::Clear();
  clear_has_price();
}
inline const ::price::PriceItem& ChargePrice::price() const {
  return price_ != NULL ? *price_ : *default_instance_->price_;
}
inline ::price::PriceItem* ChargePrice::mutable_price() {
  set_has_price();
  if (price_ == NULL) price_ = new ::price::PriceItem;
  return price_;
}
inline ::price::PriceItem* ChargePrice::release_price() {
  clear_has_price();
  ::price::PriceItem* temp = price_;
  price_ = NULL;
  return temp;
}

// optional .price.PriceItem price_ori = 2;
inline bool ChargePrice::has_price_ori() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ChargePrice::set_has_price_ori() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ChargePrice::clear_has_price_ori() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ChargePrice::clear_price_ori() {
  if (price_ori_ != NULL) price_ori_->::price::PriceItem::Clear();
  clear_has_price_ori();
}
inline const ::price::PriceItem& ChargePrice::price_ori() const {
  return price_ori_ != NULL ? *price_ori_ : *default_instance_->price_ori_;
}
inline ::price::PriceItem* ChargePrice::mutable_price_ori() {
  set_has_price_ori();
  if (price_ori_ == NULL) price_ori_ = new ::price::PriceItem;
  return price_ori_;
}
inline ::price::PriceItem* ChargePrice::release_price_ori() {
  clear_has_price_ori();
  ::price::PriceItem* temp = price_ori_;
  price_ori_ = NULL;
  return temp;
}

// required bytes description = 3;
inline bool ChargePrice::has_description() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ChargePrice::set_has_description() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ChargePrice::clear_has_description() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ChargePrice::clear_description() {
  if (description_ != &::google::protobuf::internal::kEmptyString) {
    description_->clear();
  }
  clear_has_description();
}
inline const ::std::string& ChargePrice::description() const {
  return *description_;
}
inline void ChargePrice::set_description(const ::std::string& value) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(value);
}
inline void ChargePrice::set_description(const char* value) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(value);
}
inline void ChargePrice::set_description(const void* value, size_t size) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ChargePrice::mutable_description() {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  return description_;
}
inline ::std::string* ChargePrice::release_description() {
  clear_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = description_;
    description_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional .price.ChargePriceType type = 4 [default = UNKNOWN];
inline bool ChargePrice::has_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ChargePrice::set_has_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ChargePrice::clear_has_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ChargePrice::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline price::ChargePriceType ChargePrice::type() const {
  return static_cast< price::ChargePriceType >(type_);
}
inline void ChargePrice::set_type(price::ChargePriceType value) {
  GOOGLE_DCHECK(price::ChargePriceType_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional bool included = 5 [default = true];
inline bool ChargePrice::has_included() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ChargePrice::set_has_included() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ChargePrice::clear_has_included() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ChargePrice::clear_included() {
  included_ = true;
  clear_has_included();
}
inline bool ChargePrice::included() const {
  return included_;
}
inline void ChargePrice::set_included(bool value) {
  set_has_included();
  included_ = value;
}

// optional .price.ChargePriceMode charge_price_mode = 6;
inline bool ChargePrice::has_charge_price_mode() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ChargePrice::set_has_charge_price_mode() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ChargePrice::clear_has_charge_price_mode() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ChargePrice::clear_charge_price_mode() {
  charge_price_mode_ = 0;
  clear_has_charge_price_mode();
}
inline price::ChargePriceMode ChargePrice::charge_price_mode() const {
  return static_cast< price::ChargePriceMode >(charge_price_mode_);
}
inline void ChargePrice::set_charge_price_mode(price::ChargePriceMode value) {
  GOOGLE_DCHECK(price::ChargePriceMode_IsValid(value));
  set_has_charge_price_mode();
  charge_price_mode_ = value;
}

// optional string charge_amount = 7;
inline bool ChargePrice::has_charge_amount() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ChargePrice::set_has_charge_amount() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ChargePrice::clear_has_charge_amount() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ChargePrice::clear_charge_amount() {
  if (charge_amount_ != &::google::protobuf::internal::kEmptyString) {
    charge_amount_->clear();
  }
  clear_has_charge_amount();
}
inline const ::std::string& ChargePrice::charge_amount() const {
  return *charge_amount_;
}
inline void ChargePrice::set_charge_amount(const ::std::string& value) {
  set_has_charge_amount();
  if (charge_amount_ == &::google::protobuf::internal::kEmptyString) {
    charge_amount_ = new ::std::string;
  }
  charge_amount_->assign(value);
}
inline void ChargePrice::set_charge_amount(const char* value) {
  set_has_charge_amount();
  if (charge_amount_ == &::google::protobuf::internal::kEmptyString) {
    charge_amount_ = new ::std::string;
  }
  charge_amount_->assign(value);
}
inline void ChargePrice::set_charge_amount(const char* value, size_t size) {
  set_has_charge_amount();
  if (charge_amount_ == &::google::protobuf::internal::kEmptyString) {
    charge_amount_ = new ::std::string;
  }
  charge_amount_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ChargePrice::mutable_charge_amount() {
  set_has_charge_amount();
  if (charge_amount_ == &::google::protobuf::internal::kEmptyString) {
    charge_amount_ = new ::std::string;
  }
  return charge_amount_;
}
inline ::std::string* ChargePrice::release_charge_amount() {
  clear_has_charge_amount();
  if (charge_amount_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = charge_amount_;
    charge_amount_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string charge_amount_currency = 8;
inline bool ChargePrice::has_charge_amount_currency() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ChargePrice::set_has_charge_amount_currency() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ChargePrice::clear_has_charge_amount_currency() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ChargePrice::clear_charge_amount_currency() {
  if (charge_amount_currency_ != &::google::protobuf::internal::kEmptyString) {
    charge_amount_currency_->clear();
  }
  clear_has_charge_amount_currency();
}
inline const ::std::string& ChargePrice::charge_amount_currency() const {
  return *charge_amount_currency_;
}
inline void ChargePrice::set_charge_amount_currency(const ::std::string& value) {
  set_has_charge_amount_currency();
  if (charge_amount_currency_ == &::google::protobuf::internal::kEmptyString) {
    charge_amount_currency_ = new ::std::string;
  }
  charge_amount_currency_->assign(value);
}
inline void ChargePrice::set_charge_amount_currency(const char* value) {
  set_has_charge_amount_currency();
  if (charge_amount_currency_ == &::google::protobuf::internal::kEmptyString) {
    charge_amount_currency_ = new ::std::string;
  }
  charge_amount_currency_->assign(value);
}
inline void ChargePrice::set_charge_amount_currency(const char* value, size_t size) {
  set_has_charge_amount_currency();
  if (charge_amount_currency_ == &::google::protobuf::internal::kEmptyString) {
    charge_amount_currency_ = new ::std::string;
  }
  charge_amount_currency_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ChargePrice::mutable_charge_amount_currency() {
  set_has_charge_amount_currency();
  if (charge_amount_currency_ == &::google::protobuf::internal::kEmptyString) {
    charge_amount_currency_ = new ::std::string;
  }
  return charge_amount_currency_;
}
inline ::std::string* ChargePrice::release_charge_amount_currency() {
  clear_has_charge_amount_currency();
  if (charge_amount_currency_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = charge_amount_currency_;
    charge_amount_currency_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// BoardInfo

// required bool included = 1;
inline bool BoardInfo::has_included() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BoardInfo::set_has_included() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BoardInfo::clear_has_included() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BoardInfo::clear_included() {
  included_ = false;
  clear_has_included();
}
inline bool BoardInfo::included() const {
  return included_;
}
inline void BoardInfo::set_included(bool value) {
  set_has_included();
  included_ = value;
}

// optional bytes description = 2;
inline bool BoardInfo::has_description() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BoardInfo::set_has_description() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BoardInfo::clear_has_description() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BoardInfo::clear_description() {
  if (description_ != &::google::protobuf::internal::kEmptyString) {
    description_->clear();
  }
  clear_has_description();
}
inline const ::std::string& BoardInfo::description() const {
  return *description_;
}
inline void BoardInfo::set_description(const ::std::string& value) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(value);
}
inline void BoardInfo::set_description(const char* value) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(value);
}
inline void BoardInfo::set_description(const void* value, size_t size) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BoardInfo::mutable_description() {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  return description_;
}
inline ::std::string* BoardInfo::release_description() {
  clear_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = description_;
    description_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 number = 3;
inline bool BoardInfo::has_number() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BoardInfo::set_has_number() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BoardInfo::clear_has_number() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BoardInfo::clear_number() {
  number_ = 0;
  clear_has_number();
}
inline ::google::protobuf::int32 BoardInfo::number() const {
  return number_;
}
inline void BoardInfo::set_number(::google::protobuf::int32 value) {
  set_has_number();
  number_ = value;
}

// -------------------------------------------------------------------

// ImageLink

// optional string image_id = 1;
inline bool ImageLink::has_image_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ImageLink::set_has_image_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ImageLink::clear_has_image_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ImageLink::clear_image_id() {
  if (image_id_ != &::google::protobuf::internal::kEmptyString) {
    image_id_->clear();
  }
  clear_has_image_id();
}
inline const ::std::string& ImageLink::image_id() const {
  return *image_id_;
}
inline void ImageLink::set_image_id(const ::std::string& value) {
  set_has_image_id();
  if (image_id_ == &::google::protobuf::internal::kEmptyString) {
    image_id_ = new ::std::string;
  }
  image_id_->assign(value);
}
inline void ImageLink::set_image_id(const char* value) {
  set_has_image_id();
  if (image_id_ == &::google::protobuf::internal::kEmptyString) {
    image_id_ = new ::std::string;
  }
  image_id_->assign(value);
}
inline void ImageLink::set_image_id(const char* value, size_t size) {
  set_has_image_id();
  if (image_id_ == &::google::protobuf::internal::kEmptyString) {
    image_id_ = new ::std::string;
  }
  image_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ImageLink::mutable_image_id() {
  set_has_image_id();
  if (image_id_ == &::google::protobuf::internal::kEmptyString) {
    image_id_ = new ::std::string;
  }
  return image_id_;
}
inline ::std::string* ImageLink::release_image_id() {
  clear_has_image_id();
  if (image_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = image_id_;
    image_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string image_url = 2;
inline bool ImageLink::has_image_url() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ImageLink::set_has_image_url() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ImageLink::clear_has_image_url() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ImageLink::clear_image_url() {
  if (image_url_ != &::google::protobuf::internal::kEmptyString) {
    image_url_->clear();
  }
  clear_has_image_url();
}
inline const ::std::string& ImageLink::image_url() const {
  return *image_url_;
}
inline void ImageLink::set_image_url(const ::std::string& value) {
  set_has_image_url();
  if (image_url_ == &::google::protobuf::internal::kEmptyString) {
    image_url_ = new ::std::string;
  }
  image_url_->assign(value);
}
inline void ImageLink::set_image_url(const char* value) {
  set_has_image_url();
  if (image_url_ == &::google::protobuf::internal::kEmptyString) {
    image_url_ = new ::std::string;
  }
  image_url_->assign(value);
}
inline void ImageLink::set_image_url(const char* value, size_t size) {
  set_has_image_url();
  if (image_url_ == &::google::protobuf::internal::kEmptyString) {
    image_url_ = new ::std::string;
  }
  image_url_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ImageLink::mutable_image_url() {
  set_has_image_url();
  if (image_url_ == &::google::protobuf::internal::kEmptyString) {
    image_url_ = new ::std::string;
  }
  return image_url_;
}
inline ::std::string* ImageLink::release_image_url() {
  clear_has_image_url();
  if (image_url_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = image_url_;
    image_url_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// ExtraCharge

// required .price.PriceItem total = 1;
inline bool ExtraCharge::has_total() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ExtraCharge::set_has_total() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ExtraCharge::clear_has_total() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ExtraCharge::clear_total() {
  if (total_ != NULL) total_->::price::PriceItem::Clear();
  clear_has_total();
}
inline const ::price::PriceItem& ExtraCharge::total() const {
  return total_ != NULL ? *total_ : *default_instance_->total_;
}
inline ::price::PriceItem* ExtraCharge::mutable_total() {
  set_has_total();
  if (total_ == NULL) total_ = new ::price::PriceItem;
  return total_;
}
inline ::price::PriceItem* ExtraCharge::release_total() {
  clear_has_total();
  ::price::PriceItem* temp = total_;
  total_ = NULL;
  return temp;
}

// required .price.PriceItem total_ori = 2;
inline bool ExtraCharge::has_total_ori() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ExtraCharge::set_has_total_ori() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ExtraCharge::clear_has_total_ori() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ExtraCharge::clear_total_ori() {
  if (total_ori_ != NULL) total_ori_->::price::PriceItem::Clear();
  clear_has_total_ori();
}
inline const ::price::PriceItem& ExtraCharge::total_ori() const {
  return total_ori_ != NULL ? *total_ori_ : *default_instance_->total_ori_;
}
inline ::price::PriceItem* ExtraCharge::mutable_total_ori() {
  set_has_total_ori();
  if (total_ori_ == NULL) total_ori_ = new ::price::PriceItem;
  return total_ori_;
}
inline ::price::PriceItem* ExtraCharge::release_total_ori() {
  clear_has_total_ori();
  ::price::PriceItem* temp = total_ori_;
  total_ori_ = NULL;
  return temp;
}

// repeated .price.ChargePrice charge_price_list = 3;
inline int ExtraCharge::charge_price_list_size() const {
  return charge_price_list_.size();
}
inline void ExtraCharge::clear_charge_price_list() {
  charge_price_list_.Clear();
}
inline const ::price::ChargePrice& ExtraCharge::charge_price_list(int index) const {
  return charge_price_list_.Get(index);
}
inline ::price::ChargePrice* ExtraCharge::mutable_charge_price_list(int index) {
  return charge_price_list_.Mutable(index);
}
inline ::price::ChargePrice* ExtraCharge::add_charge_price_list() {
  return charge_price_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::price::ChargePrice >&
ExtraCharge::charge_price_list() const {
  return charge_price_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::price::ChargePrice >*
ExtraCharge::mutable_charge_price_list() {
  return &charge_price_list_;
}

// -------------------------------------------------------------------

// RatePlan

// optional bool is_instant_confirm = 1 [default = true];
inline bool RatePlan::has_is_instant_confirm() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RatePlan::set_has_is_instant_confirm() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RatePlan::clear_has_is_instant_confirm() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RatePlan::clear_is_instant_confirm() {
  is_instant_confirm_ = true;
  clear_has_is_instant_confirm();
}
inline bool RatePlan::is_instant_confirm() const {
  return is_instant_confirm_;
}
inline void RatePlan::set_is_instant_confirm(bool value) {
  set_has_is_instant_confirm();
  is_instant_confirm_ = value;
}

// optional bool breakfast_included = 2 [default = false];
inline bool RatePlan::has_breakfast_included() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RatePlan::set_has_breakfast_included() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RatePlan::clear_has_breakfast_included() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RatePlan::clear_breakfast_included() {
  breakfast_included_ = false;
  clear_has_breakfast_included();
}
inline bool RatePlan::breakfast_included() const {
  return breakfast_included_;
}
inline void RatePlan::set_breakfast_included(bool value) {
  set_has_breakfast_included();
  breakfast_included_ = value;
}

// optional bool halfboard_included = 3 [default = false];
inline bool RatePlan::has_halfboard_included() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RatePlan::set_has_halfboard_included() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RatePlan::clear_has_halfboard_included() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RatePlan::clear_halfboard_included() {
  halfboard_included_ = false;
  clear_has_halfboard_included();
}
inline bool RatePlan::halfboard_included() const {
  return halfboard_included_;
}
inline void RatePlan::set_halfboard_included(bool value) {
  set_has_halfboard_included();
  halfboard_included_ = value;
}

// optional bool fullboard_included = 4 [default = false];
inline bool RatePlan::has_fullboard_included() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RatePlan::set_has_fullboard_included() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RatePlan::clear_has_fullboard_included() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RatePlan::clear_fullboard_included() {
  fullboard_included_ = false;
  clear_has_fullboard_included();
}
inline bool RatePlan::fullboard_included() const {
  return fullboard_included_;
}
inline void RatePlan::set_fullboard_included(bool value) {
  set_has_fullboard_included();
  fullboard_included_ = value;
}

// optional bool internet_included = 5 [default = false];
inline bool RatePlan::has_internet_included() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RatePlan::set_has_internet_included() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RatePlan::clear_has_internet_included() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RatePlan::clear_internet_included() {
  internet_included_ = false;
  clear_has_internet_included();
}
inline bool RatePlan::internet_included() const {
  return internet_included_;
}
inline void RatePlan::set_internet_included(bool value) {
  set_has_internet_included();
  internet_included_ = value;
}

// optional bool wifi_included = 6 [default = false];
inline bool RatePlan::has_wifi_included() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RatePlan::set_has_wifi_included() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RatePlan::clear_has_wifi_included() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RatePlan::clear_wifi_included() {
  wifi_included_ = false;
  clear_has_wifi_included();
}
inline bool RatePlan::wifi_included() const {
  return wifi_included_;
}
inline void RatePlan::set_wifi_included(bool value) {
  set_has_wifi_included();
  wifi_included_ = value;
}

// optional int32 ota_promo_type = 7;
inline bool RatePlan::has_ota_promo_type() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void RatePlan::set_has_ota_promo_type() {
  _has_bits_[0] |= 0x00000040u;
}
inline void RatePlan::clear_has_ota_promo_type() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void RatePlan::clear_ota_promo_type() {
  ota_promo_type_ = 0;
  clear_has_ota_promo_type();
}
inline ::google::protobuf::int32 RatePlan::ota_promo_type() const {
  return ota_promo_type_;
}
inline void RatePlan::set_ota_promo_type(::google::protobuf::int32 value) {
  set_has_ota_promo_type();
  ota_promo_type_ = value;
}

// optional .price.UserInfo user_info = 8;
inline bool RatePlan::has_user_info() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void RatePlan::set_has_user_info() {
  _has_bits_[0] |= 0x00000080u;
}
inline void RatePlan::clear_has_user_info() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void RatePlan::clear_user_info() {
  if (user_info_ != NULL) user_info_->::price::UserInfo::Clear();
  clear_has_user_info();
}
inline const ::price::UserInfo& RatePlan::user_info() const {
  return user_info_ != NULL ? *user_info_ : *default_instance_->user_info_;
}
inline ::price::UserInfo* RatePlan::mutable_user_info() {
  set_has_user_info();
  if (user_info_ == NULL) user_info_ = new ::price::UserInfo;
  return user_info_;
}
inline ::price::UserInfo* RatePlan::release_user_info() {
  clear_has_user_info();
  ::price::UserInfo* temp = user_info_;
  user_info_ = NULL;
  return temp;
}

// optional .price.PayType pay_type = 9 [default = PRE_PAY];
inline bool RatePlan::has_pay_type() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void RatePlan::set_has_pay_type() {
  _has_bits_[0] |= 0x00000100u;
}
inline void RatePlan::clear_has_pay_type() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void RatePlan::clear_pay_type() {
  pay_type_ = 1;
  clear_has_pay_type();
}
inline price::PayType RatePlan::pay_type() const {
  return static_cast< price::PayType >(pay_type_);
}
inline void RatePlan::set_pay_type(price::PayType value) {
  GOOGLE_DCHECK(price::PayType_IsValid(value));
  set_has_pay_type();
  pay_type_ = value;
}

// optional .price.GuaranteeAndDeposit guarantee_and_deposit = 10;
inline bool RatePlan::has_guarantee_and_deposit() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void RatePlan::set_has_guarantee_and_deposit() {
  _has_bits_[0] |= 0x00000200u;
}
inline void RatePlan::clear_has_guarantee_and_deposit() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void RatePlan::clear_guarantee_and_deposit() {
  if (guarantee_and_deposit_ != NULL) guarantee_and_deposit_->::price::GuaranteeAndDeposit::Clear();
  clear_has_guarantee_and_deposit();
}
inline const ::price::GuaranteeAndDeposit& RatePlan::guarantee_and_deposit() const {
  return guarantee_and_deposit_ != NULL ? *guarantee_and_deposit_ : *default_instance_->guarantee_and_deposit_;
}
inline ::price::GuaranteeAndDeposit* RatePlan::mutable_guarantee_and_deposit() {
  set_has_guarantee_and_deposit();
  if (guarantee_and_deposit_ == NULL) guarantee_and_deposit_ = new ::price::GuaranteeAndDeposit;
  return guarantee_and_deposit_;
}
inline ::price::GuaranteeAndDeposit* RatePlan::release_guarantee_and_deposit() {
  clear_has_guarantee_and_deposit();
  ::price::GuaranteeAndDeposit* temp = guarantee_and_deposit_;
  guarantee_and_deposit_ = NULL;
  return temp;
}

// repeated .price.PromotionInfo promotion_info_list = 11;
inline int RatePlan::promotion_info_list_size() const {
  return promotion_info_list_.size();
}
inline void RatePlan::clear_promotion_info_list() {
  promotion_info_list_.Clear();
}
inline const ::price::PromotionInfo& RatePlan::promotion_info_list(int index) const {
  return promotion_info_list_.Get(index);
}
inline ::price::PromotionInfo* RatePlan::mutable_promotion_info_list(int index) {
  return promotion_info_list_.Mutable(index);
}
inline ::price::PromotionInfo* RatePlan::add_promotion_info_list() {
  return promotion_info_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::price::PromotionInfo >&
RatePlan::promotion_info_list() const {
  return promotion_info_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::price::PromotionInfo >*
RatePlan::mutable_promotion_info_list() {
  return &promotion_info_list_;
}

// repeated .price.CancellationInfo cancellation_info_list = 12;
inline int RatePlan::cancellation_info_list_size() const {
  return cancellation_info_list_.size();
}
inline void RatePlan::clear_cancellation_info_list() {
  cancellation_info_list_.Clear();
}
inline const ::price::CancellationInfo& RatePlan::cancellation_info_list(int index) const {
  return cancellation_info_list_.Get(index);
}
inline ::price::CancellationInfo* RatePlan::mutable_cancellation_info_list(int index) {
  return cancellation_info_list_.Mutable(index);
}
inline ::price::CancellationInfo* RatePlan::add_cancellation_info_list() {
  return cancellation_info_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::price::CancellationInfo >&
RatePlan::cancellation_info_list() const {
  return cancellation_info_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::price::CancellationInfo >*
RatePlan::mutable_cancellation_info_list() {
  return &cancellation_info_list_;
}

// repeated .price.CancellationInfo elong_cancellation_info_list = 13;
inline int RatePlan::elong_cancellation_info_list_size() const {
  return elong_cancellation_info_list_.size();
}
inline void RatePlan::clear_elong_cancellation_info_list() {
  elong_cancellation_info_list_.Clear();
}
inline const ::price::CancellationInfo& RatePlan::elong_cancellation_info_list(int index) const {
  return elong_cancellation_info_list_.Get(index);
}
inline ::price::CancellationInfo* RatePlan::mutable_elong_cancellation_info_list(int index) {
  return elong_cancellation_info_list_.Mutable(index);
}
inline ::price::CancellationInfo* RatePlan::add_elong_cancellation_info_list() {
  return elong_cancellation_info_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::price::CancellationInfo >&
RatePlan::elong_cancellation_info_list() const {
  return elong_cancellation_info_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::price::CancellationInfo >*
RatePlan::mutable_elong_cancellation_info_list() {
  return &elong_cancellation_info_list_;
}

// -------------------------------------------------------------------

// ProductDesc

// repeated .price.BoardInfo board_info_list = 1;
inline int ProductDesc::board_info_list_size() const {
  return board_info_list_.size();
}
inline void ProductDesc::clear_board_info_list() {
  board_info_list_.Clear();
}
inline const ::price::BoardInfo& ProductDesc::board_info_list(int index) const {
  return board_info_list_.Get(index);
}
inline ::price::BoardInfo* ProductDesc::mutable_board_info_list(int index) {
  return board_info_list_.Mutable(index);
}
inline ::price::BoardInfo* ProductDesc::add_board_info_list() {
  return board_info_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::price::BoardInfo >&
ProductDesc::board_info_list() const {
  return board_info_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::price::BoardInfo >*
ProductDesc::mutable_board_info_list() {
  return &board_info_list_;
}

// repeated .price.BedGroup product_bed_group = 2;
inline int ProductDesc::product_bed_group_size() const {
  return product_bed_group_.size();
}
inline void ProductDesc::clear_product_bed_group() {
  product_bed_group_.Clear();
}
inline const ::price::BedGroup& ProductDesc::product_bed_group(int index) const {
  return product_bed_group_.Get(index);
}
inline ::price::BedGroup* ProductDesc::mutable_product_bed_group(int index) {
  return product_bed_group_.Mutable(index);
}
inline ::price::BedGroup* ProductDesc::add_product_bed_group() {
  return product_bed_group_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::price::BedGroup >&
ProductDesc::product_bed_group() const {
  return product_bed_group_;
}
inline ::google::protobuf::RepeatedPtrField< ::price::BedGroup >*
ProductDesc::mutable_product_bed_group() {
  return &product_bed_group_;
}

// optional bytes rate_comment = 3;
inline bool ProductDesc::has_rate_comment() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ProductDesc::set_has_rate_comment() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ProductDesc::clear_has_rate_comment() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ProductDesc::clear_rate_comment() {
  if (rate_comment_ != &::google::protobuf::internal::kEmptyString) {
    rate_comment_->clear();
  }
  clear_has_rate_comment();
}
inline const ::std::string& ProductDesc::rate_comment() const {
  return *rate_comment_;
}
inline void ProductDesc::set_rate_comment(const ::std::string& value) {
  set_has_rate_comment();
  if (rate_comment_ == &::google::protobuf::internal::kEmptyString) {
    rate_comment_ = new ::std::string;
  }
  rate_comment_->assign(value);
}
inline void ProductDesc::set_rate_comment(const char* value) {
  set_has_rate_comment();
  if (rate_comment_ == &::google::protobuf::internal::kEmptyString) {
    rate_comment_ = new ::std::string;
  }
  rate_comment_->assign(value);
}
inline void ProductDesc::set_rate_comment(const void* value, size_t size) {
  set_has_rate_comment();
  if (rate_comment_ == &::google::protobuf::internal::kEmptyString) {
    rate_comment_ = new ::std::string;
  }
  rate_comment_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ProductDesc::mutable_rate_comment() {
  set_has_rate_comment();
  if (rate_comment_ == &::google::protobuf::internal::kEmptyString) {
    rate_comment_ = new ::std::string;
  }
  return rate_comment_;
}
inline ::std::string* ProductDesc::release_rate_comment() {
  clear_has_rate_comment();
  if (rate_comment_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = rate_comment_;
    rate_comment_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bytes prepay_desc = 4;
inline bool ProductDesc::has_prepay_desc() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ProductDesc::set_has_prepay_desc() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ProductDesc::clear_has_prepay_desc() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ProductDesc::clear_prepay_desc() {
  if (prepay_desc_ != &::google::protobuf::internal::kEmptyString) {
    prepay_desc_->clear();
  }
  clear_has_prepay_desc();
}
inline const ::std::string& ProductDesc::prepay_desc() const {
  return *prepay_desc_;
}
inline void ProductDesc::set_prepay_desc(const ::std::string& value) {
  set_has_prepay_desc();
  if (prepay_desc_ == &::google::protobuf::internal::kEmptyString) {
    prepay_desc_ = new ::std::string;
  }
  prepay_desc_->assign(value);
}
inline void ProductDesc::set_prepay_desc(const char* value) {
  set_has_prepay_desc();
  if (prepay_desc_ == &::google::protobuf::internal::kEmptyString) {
    prepay_desc_ = new ::std::string;
  }
  prepay_desc_->assign(value);
}
inline void ProductDesc::set_prepay_desc(const void* value, size_t size) {
  set_has_prepay_desc();
  if (prepay_desc_ == &::google::protobuf::internal::kEmptyString) {
    prepay_desc_ = new ::std::string;
  }
  prepay_desc_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ProductDesc::mutable_prepay_desc() {
  set_has_prepay_desc();
  if (prepay_desc_ == &::google::protobuf::internal::kEmptyString) {
    prepay_desc_ = new ::std::string;
  }
  return prepay_desc_;
}
inline ::std::string* ProductDesc::release_prepay_desc() {
  clear_has_prepay_desc();
  if (prepay_desc_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = prepay_desc_;
    prepay_desc_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bytes cancellation_desc_cn = 5;
inline bool ProductDesc::has_cancellation_desc_cn() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ProductDesc::set_has_cancellation_desc_cn() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ProductDesc::clear_has_cancellation_desc_cn() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ProductDesc::clear_cancellation_desc_cn() {
  if (cancellation_desc_cn_ != &::google::protobuf::internal::kEmptyString) {
    cancellation_desc_cn_->clear();
  }
  clear_has_cancellation_desc_cn();
}
inline const ::std::string& ProductDesc::cancellation_desc_cn() const {
  return *cancellation_desc_cn_;
}
inline void ProductDesc::set_cancellation_desc_cn(const ::std::string& value) {
  set_has_cancellation_desc_cn();
  if (cancellation_desc_cn_ == &::google::protobuf::internal::kEmptyString) {
    cancellation_desc_cn_ = new ::std::string;
  }
  cancellation_desc_cn_->assign(value);
}
inline void ProductDesc::set_cancellation_desc_cn(const char* value) {
  set_has_cancellation_desc_cn();
  if (cancellation_desc_cn_ == &::google::protobuf::internal::kEmptyString) {
    cancellation_desc_cn_ = new ::std::string;
  }
  cancellation_desc_cn_->assign(value);
}
inline void ProductDesc::set_cancellation_desc_cn(const void* value, size_t size) {
  set_has_cancellation_desc_cn();
  if (cancellation_desc_cn_ == &::google::protobuf::internal::kEmptyString) {
    cancellation_desc_cn_ = new ::std::string;
  }
  cancellation_desc_cn_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ProductDesc::mutable_cancellation_desc_cn() {
  set_has_cancellation_desc_cn();
  if (cancellation_desc_cn_ == &::google::protobuf::internal::kEmptyString) {
    cancellation_desc_cn_ = new ::std::string;
  }
  return cancellation_desc_cn_;
}
inline ::std::string* ProductDesc::release_cancellation_desc_cn() {
  clear_has_cancellation_desc_cn();
  if (cancellation_desc_cn_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = cancellation_desc_cn_;
    cancellation_desc_cn_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bytes cancellation_desc_en = 6;
inline bool ProductDesc::has_cancellation_desc_en() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ProductDesc::set_has_cancellation_desc_en() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ProductDesc::clear_has_cancellation_desc_en() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ProductDesc::clear_cancellation_desc_en() {
  if (cancellation_desc_en_ != &::google::protobuf::internal::kEmptyString) {
    cancellation_desc_en_->clear();
  }
  clear_has_cancellation_desc_en();
}
inline const ::std::string& ProductDesc::cancellation_desc_en() const {
  return *cancellation_desc_en_;
}
inline void ProductDesc::set_cancellation_desc_en(const ::std::string& value) {
  set_has_cancellation_desc_en();
  if (cancellation_desc_en_ == &::google::protobuf::internal::kEmptyString) {
    cancellation_desc_en_ = new ::std::string;
  }
  cancellation_desc_en_->assign(value);
}
inline void ProductDesc::set_cancellation_desc_en(const char* value) {
  set_has_cancellation_desc_en();
  if (cancellation_desc_en_ == &::google::protobuf::internal::kEmptyString) {
    cancellation_desc_en_ = new ::std::string;
  }
  cancellation_desc_en_->assign(value);
}
inline void ProductDesc::set_cancellation_desc_en(const void* value, size_t size) {
  set_has_cancellation_desc_en();
  if (cancellation_desc_en_ == &::google::protobuf::internal::kEmptyString) {
    cancellation_desc_en_ = new ::std::string;
  }
  cancellation_desc_en_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ProductDesc::mutable_cancellation_desc_en() {
  set_has_cancellation_desc_en();
  if (cancellation_desc_en_ == &::google::protobuf::internal::kEmptyString) {
    cancellation_desc_en_ = new ::std::string;
  }
  return cancellation_desc_en_;
}
inline ::std::string* ProductDesc::release_cancellation_desc_en() {
  clear_has_cancellation_desc_en();
  if (cancellation_desc_en_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = cancellation_desc_en_;
    cancellation_desc_en_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated .price.CreditCard product_credit_card = 7;
inline int ProductDesc::product_credit_card_size() const {
  return product_credit_card_.size();
}
inline void ProductDesc::clear_product_credit_card() {
  product_credit_card_.Clear();
}
inline const ::price::CreditCard& ProductDesc::product_credit_card(int index) const {
  return product_credit_card_.Get(index);
}
inline ::price::CreditCard* ProductDesc::mutable_product_credit_card(int index) {
  return product_credit_card_.Mutable(index);
}
inline ::price::CreditCard* ProductDesc::add_product_credit_card() {
  return product_credit_card_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::price::CreditCard >&
ProductDesc::product_credit_card() const {
  return product_credit_card_;
}
inline ::google::protobuf::RepeatedPtrField< ::price::CreditCard >*
ProductDesc::mutable_product_credit_card() {
  return &product_credit_card_;
}

// -------------------------------------------------------------------

// RoomDesc

// optional bytes room_desc_text = 1;
inline bool RoomDesc::has_room_desc_text() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RoomDesc::set_has_room_desc_text() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RoomDesc::clear_has_room_desc_text() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RoomDesc::clear_room_desc_text() {
  if (room_desc_text_ != &::google::protobuf::internal::kEmptyString) {
    room_desc_text_->clear();
  }
  clear_has_room_desc_text();
}
inline const ::std::string& RoomDesc::room_desc_text() const {
  return *room_desc_text_;
}
inline void RoomDesc::set_room_desc_text(const ::std::string& value) {
  set_has_room_desc_text();
  if (room_desc_text_ == &::google::protobuf::internal::kEmptyString) {
    room_desc_text_ = new ::std::string;
  }
  room_desc_text_->assign(value);
}
inline void RoomDesc::set_room_desc_text(const char* value) {
  set_has_room_desc_text();
  if (room_desc_text_ == &::google::protobuf::internal::kEmptyString) {
    room_desc_text_ = new ::std::string;
  }
  room_desc_text_->assign(value);
}
inline void RoomDesc::set_room_desc_text(const void* value, size_t size) {
  set_has_room_desc_text();
  if (room_desc_text_ == &::google::protobuf::internal::kEmptyString) {
    room_desc_text_ = new ::std::string;
  }
  room_desc_text_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RoomDesc::mutable_room_desc_text() {
  set_has_room_desc_text();
  if (room_desc_text_ == &::google::protobuf::internal::kEmptyString) {
    room_desc_text_ = new ::std::string;
  }
  return room_desc_text_;
}
inline ::std::string* RoomDesc::release_room_desc_text() {
  clear_has_room_desc_text();
  if (room_desc_text_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = room_desc_text_;
    room_desc_text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated .price.BedGroup room_bed_group = 2;
inline int RoomDesc::room_bed_group_size() const {
  return room_bed_group_.size();
}
inline void RoomDesc::clear_room_bed_group() {
  room_bed_group_.Clear();
}
inline const ::price::BedGroup& RoomDesc::room_bed_group(int index) const {
  return room_bed_group_.Get(index);
}
inline ::price::BedGroup* RoomDesc::mutable_room_bed_group(int index) {
  return room_bed_group_.Mutable(index);
}
inline ::price::BedGroup* RoomDesc::add_room_bed_group() {
  return room_bed_group_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::price::BedGroup >&
RoomDesc::room_bed_group() const {
  return room_bed_group_;
}
inline ::google::protobuf::RepeatedPtrField< ::price::BedGroup >*
RoomDesc::mutable_room_bed_group() {
  return &room_bed_group_;
}

// repeated .price.ImageLink image_link_list = 3;
inline int RoomDesc::image_link_list_size() const {
  return image_link_list_.size();
}
inline void RoomDesc::clear_image_link_list() {
  image_link_list_.Clear();
}
inline const ::price::ImageLink& RoomDesc::image_link_list(int index) const {
  return image_link_list_.Get(index);
}
inline ::price::ImageLink* RoomDesc::mutable_image_link_list(int index) {
  return image_link_list_.Mutable(index);
}
inline ::price::ImageLink* RoomDesc::add_image_link_list() {
  return image_link_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::price::ImageLink >&
RoomDesc::image_link_list() const {
  return image_link_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::price::ImageLink >*
RoomDesc::mutable_image_link_list() {
  return &image_link_list_;
}

// optional bytes internet = 4;
inline bool RoomDesc::has_internet() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RoomDesc::set_has_internet() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RoomDesc::clear_has_internet() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RoomDesc::clear_internet() {
  if (internet_ != &::google::protobuf::internal::kEmptyString) {
    internet_->clear();
  }
  clear_has_internet();
}
inline const ::std::string& RoomDesc::internet() const {
  return *internet_;
}
inline void RoomDesc::set_internet(const ::std::string& value) {
  set_has_internet();
  if (internet_ == &::google::protobuf::internal::kEmptyString) {
    internet_ = new ::std::string;
  }
  internet_->assign(value);
}
inline void RoomDesc::set_internet(const char* value) {
  set_has_internet();
  if (internet_ == &::google::protobuf::internal::kEmptyString) {
    internet_ = new ::std::string;
  }
  internet_->assign(value);
}
inline void RoomDesc::set_internet(const void* value, size_t size) {
  set_has_internet();
  if (internet_ == &::google::protobuf::internal::kEmptyString) {
    internet_ = new ::std::string;
  }
  internet_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RoomDesc::mutable_internet() {
  set_has_internet();
  if (internet_ == &::google::protobuf::internal::kEmptyString) {
    internet_ = new ::std::string;
  }
  return internet_;
}
inline ::std::string* RoomDesc::release_internet() {
  clear_has_internet();
  if (internet_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = internet_;
    internet_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bytes smoking_preferences = 5;
inline bool RoomDesc::has_smoking_preferences() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RoomDesc::set_has_smoking_preferences() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RoomDesc::clear_has_smoking_preferences() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RoomDesc::clear_smoking_preferences() {
  if (smoking_preferences_ != &::google::protobuf::internal::kEmptyString) {
    smoking_preferences_->clear();
  }
  clear_has_smoking_preferences();
}
inline const ::std::string& RoomDesc::smoking_preferences() const {
  return *smoking_preferences_;
}
inline void RoomDesc::set_smoking_preferences(const ::std::string& value) {
  set_has_smoking_preferences();
  if (smoking_preferences_ == &::google::protobuf::internal::kEmptyString) {
    smoking_preferences_ = new ::std::string;
  }
  smoking_preferences_->assign(value);
}
inline void RoomDesc::set_smoking_preferences(const char* value) {
  set_has_smoking_preferences();
  if (smoking_preferences_ == &::google::protobuf::internal::kEmptyString) {
    smoking_preferences_ = new ::std::string;
  }
  smoking_preferences_->assign(value);
}
inline void RoomDesc::set_smoking_preferences(const void* value, size_t size) {
  set_has_smoking_preferences();
  if (smoking_preferences_ == &::google::protobuf::internal::kEmptyString) {
    smoking_preferences_ = new ::std::string;
  }
  smoking_preferences_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RoomDesc::mutable_smoking_preferences() {
  set_has_smoking_preferences();
  if (smoking_preferences_ == &::google::protobuf::internal::kEmptyString) {
    smoking_preferences_ = new ::std::string;
  }
  return smoking_preferences_;
}
inline ::std::string* RoomDesc::release_smoking_preferences() {
  clear_has_smoking_preferences();
  if (smoking_preferences_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = smoking_preferences_;
    smoking_preferences_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bytes meal_desc = 6;
inline bool RoomDesc::has_meal_desc() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RoomDesc::set_has_meal_desc() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RoomDesc::clear_has_meal_desc() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RoomDesc::clear_meal_desc() {
  if (meal_desc_ != &::google::protobuf::internal::kEmptyString) {
    meal_desc_->clear();
  }
  clear_has_meal_desc();
}
inline const ::std::string& RoomDesc::meal_desc() const {
  return *meal_desc_;
}
inline void RoomDesc::set_meal_desc(const ::std::string& value) {
  set_has_meal_desc();
  if (meal_desc_ == &::google::protobuf::internal::kEmptyString) {
    meal_desc_ = new ::std::string;
  }
  meal_desc_->assign(value);
}
inline void RoomDesc::set_meal_desc(const char* value) {
  set_has_meal_desc();
  if (meal_desc_ == &::google::protobuf::internal::kEmptyString) {
    meal_desc_ = new ::std::string;
  }
  meal_desc_->assign(value);
}
inline void RoomDesc::set_meal_desc(const void* value, size_t size) {
  set_has_meal_desc();
  if (meal_desc_ == &::google::protobuf::internal::kEmptyString) {
    meal_desc_ = new ::std::string;
  }
  meal_desc_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RoomDesc::mutable_meal_desc() {
  set_has_meal_desc();
  if (meal_desc_ == &::google::protobuf::internal::kEmptyString) {
    meal_desc_ = new ::std::string;
  }
  return meal_desc_;
}
inline ::std::string* RoomDesc::release_meal_desc() {
  clear_has_meal_desc();
  if (meal_desc_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = meal_desc_;
    meal_desc_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bytes room_size = 7;
inline bool RoomDesc::has_room_size() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void RoomDesc::set_has_room_size() {
  _has_bits_[0] |= 0x00000040u;
}
inline void RoomDesc::clear_has_room_size() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void RoomDesc::clear_room_size() {
  if (room_size_ != &::google::protobuf::internal::kEmptyString) {
    room_size_->clear();
  }
  clear_has_room_size();
}
inline const ::std::string& RoomDesc::room_size() const {
  return *room_size_;
}
inline void RoomDesc::set_room_size(const ::std::string& value) {
  set_has_room_size();
  if (room_size_ == &::google::protobuf::internal::kEmptyString) {
    room_size_ = new ::std::string;
  }
  room_size_->assign(value);
}
inline void RoomDesc::set_room_size(const char* value) {
  set_has_room_size();
  if (room_size_ == &::google::protobuf::internal::kEmptyString) {
    room_size_ = new ::std::string;
  }
  room_size_->assign(value);
}
inline void RoomDesc::set_room_size(const void* value, size_t size) {
  set_has_room_size();
  if (room_size_ == &::google::protobuf::internal::kEmptyString) {
    room_size_ = new ::std::string;
  }
  room_size_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RoomDesc::mutable_room_size() {
  set_has_room_size();
  if (room_size_ == &::google::protobuf::internal::kEmptyString) {
    room_size_ = new ::std::string;
  }
  return room_size_;
}
inline ::std::string* RoomDesc::release_room_size() {
  clear_has_room_size();
  if (room_size_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = room_size_;
    room_size_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 has_window = 8 [default = 2];
inline bool RoomDesc::has_has_window() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void RoomDesc::set_has_has_window() {
  _has_bits_[0] |= 0x00000080u;
}
inline void RoomDesc::clear_has_has_window() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void RoomDesc::clear_has_window() {
  has_window_ = 2;
  clear_has_has_window();
}
inline ::google::protobuf::int32 RoomDesc::has_window() const {
  return has_window_;
}
inline void RoomDesc::set_has_window(::google::protobuf::int32 value) {
  set_has_has_window();
  has_window_ = value;
}

// repeated bytes facility_list = 10;
inline int RoomDesc::facility_list_size() const {
  return facility_list_.size();
}
inline void RoomDesc::clear_facility_list() {
  facility_list_.Clear();
}
inline const ::std::string& RoomDesc::facility_list(int index) const {
  return facility_list_.Get(index);
}
inline ::std::string* RoomDesc::mutable_facility_list(int index) {
  return facility_list_.Mutable(index);
}
inline void RoomDesc::set_facility_list(int index, const ::std::string& value) {
  facility_list_.Mutable(index)->assign(value);
}
inline void RoomDesc::set_facility_list(int index, const char* value) {
  facility_list_.Mutable(index)->assign(value);
}
inline void RoomDesc::set_facility_list(int index, const void* value, size_t size) {
  facility_list_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RoomDesc::add_facility_list() {
  return facility_list_.Add();
}
inline void RoomDesc::add_facility_list(const ::std::string& value) {
  facility_list_.Add()->assign(value);
}
inline void RoomDesc::add_facility_list(const char* value) {
  facility_list_.Add()->assign(value);
}
inline void RoomDesc::add_facility_list(const void* value, size_t size) {
  facility_list_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
RoomDesc::facility_list() const {
  return facility_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
RoomDesc::mutable_facility_list() {
  return &facility_list_;
}

// -------------------------------------------------------------------

// ProductFilter

// optional int32 filter_cancellation_type = 1;
inline bool ProductFilter::has_filter_cancellation_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ProductFilter::set_has_filter_cancellation_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ProductFilter::clear_has_filter_cancellation_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ProductFilter::clear_filter_cancellation_type() {
  filter_cancellation_type_ = 0;
  clear_has_filter_cancellation_type();
}
inline ::google::protobuf::int32 ProductFilter::filter_cancellation_type() const {
  return filter_cancellation_type_;
}
inline void ProductFilter::set_filter_cancellation_type(::google::protobuf::int32 value) {
  set_has_filter_cancellation_type();
  filter_cancellation_type_ = value;
}

// optional int32 filter_paytype = 2;
inline bool ProductFilter::has_filter_paytype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ProductFilter::set_has_filter_paytype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ProductFilter::clear_has_filter_paytype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ProductFilter::clear_filter_paytype() {
  filter_paytype_ = 0;
  clear_has_filter_paytype();
}
inline ::google::protobuf::int32 ProductFilter::filter_paytype() const {
  return filter_paytype_;
}
inline void ProductFilter::set_filter_paytype(::google::protobuf::int32 value) {
  set_has_filter_paytype();
  filter_paytype_ = value;
}

// optional int32 filter_internet = 3;
inline bool ProductFilter::has_filter_internet() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ProductFilter::set_has_filter_internet() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ProductFilter::clear_has_filter_internet() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ProductFilter::clear_filter_internet() {
  filter_internet_ = 0;
  clear_has_filter_internet();
}
inline ::google::protobuf::int32 ProductFilter::filter_internet() const {
  return filter_internet_;
}
inline void ProductFilter::set_filter_internet(::google::protobuf::int32 value) {
  set_has_filter_internet();
  filter_internet_ = value;
}

// optional int32 filter_boards = 4;
inline bool ProductFilter::has_filter_boards() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ProductFilter::set_has_filter_boards() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ProductFilter::clear_has_filter_boards() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ProductFilter::clear_filter_boards() {
  filter_boards_ = 0;
  clear_has_filter_boards();
}
inline ::google::protobuf::int32 ProductFilter::filter_boards() const {
  return filter_boards_;
}
inline void ProductFilter::set_filter_boards(::google::protobuf::int32 value) {
  set_has_filter_boards();
  filter_boards_ = value;
}

// repeated int32 filter_beds = 5;
inline int ProductFilter::filter_beds_size() const {
  return filter_beds_.size();
}
inline void ProductFilter::clear_filter_beds() {
  filter_beds_.Clear();
}
inline ::google::protobuf::int32 ProductFilter::filter_beds(int index) const {
  return filter_beds_.Get(index);
}
inline void ProductFilter::set_filter_beds(int index, ::google::protobuf::int32 value) {
  filter_beds_.Set(index, value);
}
inline void ProductFilter::add_filter_beds(::google::protobuf::int32 value) {
  filter_beds_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
ProductFilter::filter_beds() const {
  return filter_beds_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
ProductFilter::mutable_filter_beds() {
  return &filter_beds_;
}

// -------------------------------------------------------------------

// ProductFilterStat

// repeated int32 filter_cancellation_type = 1;
inline int ProductFilterStat::filter_cancellation_type_size() const {
  return filter_cancellation_type_.size();
}
inline void ProductFilterStat::clear_filter_cancellation_type() {
  filter_cancellation_type_.Clear();
}
inline ::google::protobuf::int32 ProductFilterStat::filter_cancellation_type(int index) const {
  return filter_cancellation_type_.Get(index);
}
inline void ProductFilterStat::set_filter_cancellation_type(int index, ::google::protobuf::int32 value) {
  filter_cancellation_type_.Set(index, value);
}
inline void ProductFilterStat::add_filter_cancellation_type(::google::protobuf::int32 value) {
  filter_cancellation_type_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
ProductFilterStat::filter_cancellation_type() const {
  return filter_cancellation_type_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
ProductFilterStat::mutable_filter_cancellation_type() {
  return &filter_cancellation_type_;
}

// repeated int32 filter_paytype = 2;
inline int ProductFilterStat::filter_paytype_size() const {
  return filter_paytype_.size();
}
inline void ProductFilterStat::clear_filter_paytype() {
  filter_paytype_.Clear();
}
inline ::google::protobuf::int32 ProductFilterStat::filter_paytype(int index) const {
  return filter_paytype_.Get(index);
}
inline void ProductFilterStat::set_filter_paytype(int index, ::google::protobuf::int32 value) {
  filter_paytype_.Set(index, value);
}
inline void ProductFilterStat::add_filter_paytype(::google::protobuf::int32 value) {
  filter_paytype_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
ProductFilterStat::filter_paytype() const {
  return filter_paytype_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
ProductFilterStat::mutable_filter_paytype() {
  return &filter_paytype_;
}

// repeated int32 filter_internet = 3;
inline int ProductFilterStat::filter_internet_size() const {
  return filter_internet_.size();
}
inline void ProductFilterStat::clear_filter_internet() {
  filter_internet_.Clear();
}
inline ::google::protobuf::int32 ProductFilterStat::filter_internet(int index) const {
  return filter_internet_.Get(index);
}
inline void ProductFilterStat::set_filter_internet(int index, ::google::protobuf::int32 value) {
  filter_internet_.Set(index, value);
}
inline void ProductFilterStat::add_filter_internet(::google::protobuf::int32 value) {
  filter_internet_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
ProductFilterStat::filter_internet() const {
  return filter_internet_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
ProductFilterStat::mutable_filter_internet() {
  return &filter_internet_;
}

// repeated int32 filter_boards = 4;
inline int ProductFilterStat::filter_boards_size() const {
  return filter_boards_.size();
}
inline void ProductFilterStat::clear_filter_boards() {
  filter_boards_.Clear();
}
inline ::google::protobuf::int32 ProductFilterStat::filter_boards(int index) const {
  return filter_boards_.Get(index);
}
inline void ProductFilterStat::set_filter_boards(int index, ::google::protobuf::int32 value) {
  filter_boards_.Set(index, value);
}
inline void ProductFilterStat::add_filter_boards(::google::protobuf::int32 value) {
  filter_boards_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
ProductFilterStat::filter_boards() const {
  return filter_boards_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
ProductFilterStat::mutable_filter_boards() {
  return &filter_boards_;
}

// repeated int32 filter_beds = 5;
inline int ProductFilterStat::filter_beds_size() const {
  return filter_beds_.size();
}
inline void ProductFilterStat::clear_filter_beds() {
  filter_beds_.Clear();
}
inline ::google::protobuf::int32 ProductFilterStat::filter_beds(int index) const {
  return filter_beds_.Get(index);
}
inline void ProductFilterStat::set_filter_beds(int index, ::google::protobuf::int32 value) {
  filter_beds_.Set(index, value);
}
inline void ProductFilterStat::add_filter_beds(::google::protobuf::int32 value) {
  filter_beds_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
ProductFilterStat::filter_beds() const {
  return filter_beds_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
ProductFilterStat::mutable_filter_beds() {
  return &filter_beds_;
}

// -------------------------------------------------------------------

// PriceInfo

// optional .price.PriceItem total_price = 1;
inline bool PriceInfo::has_total_price() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PriceInfo::set_has_total_price() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PriceInfo::clear_has_total_price() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PriceInfo::clear_total_price() {
  if (total_price_ != NULL) total_price_->::price::PriceItem::Clear();
  clear_has_total_price();
}
inline const ::price::PriceItem& PriceInfo::total_price() const {
  return total_price_ != NULL ? *total_price_ : *default_instance_->total_price_;
}
inline ::price::PriceItem* PriceInfo::mutable_total_price() {
  set_has_total_price();
  if (total_price_ == NULL) total_price_ = new ::price::PriceItem;
  return total_price_;
}
inline ::price::PriceItem* PriceInfo::release_total_price() {
  clear_has_total_price();
  ::price::PriceItem* temp = total_price_;
  total_price_ = NULL;
  return temp;
}

// optional .price.PriceItem total_price_ori = 2;
inline bool PriceInfo::has_total_price_ori() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PriceInfo::set_has_total_price_ori() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PriceInfo::clear_has_total_price_ori() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PriceInfo::clear_total_price_ori() {
  if (total_price_ori_ != NULL) total_price_ori_->::price::PriceItem::Clear();
  clear_has_total_price_ori();
}
inline const ::price::PriceItem& PriceInfo::total_price_ori() const {
  return total_price_ori_ != NULL ? *total_price_ori_ : *default_instance_->total_price_ori_;
}
inline ::price::PriceItem* PriceInfo::mutable_total_price_ori() {
  set_has_total_price_ori();
  if (total_price_ori_ == NULL) total_price_ori_ = new ::price::PriceItem;
  return total_price_ori_;
}
inline ::price::PriceItem* PriceInfo::release_total_price_ori() {
  clear_has_total_price_ori();
  ::price::PriceItem* temp = total_price_ori_;
  total_price_ori_ = NULL;
  return temp;
}

// optional .price.PriceItem total_room_price = 3;
inline bool PriceInfo::has_total_room_price() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PriceInfo::set_has_total_room_price() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PriceInfo::clear_has_total_room_price() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PriceInfo::clear_total_room_price() {
  if (total_room_price_ != NULL) total_room_price_->::price::PriceItem::Clear();
  clear_has_total_room_price();
}
inline const ::price::PriceItem& PriceInfo::total_room_price() const {
  return total_room_price_ != NULL ? *total_room_price_ : *default_instance_->total_room_price_;
}
inline ::price::PriceItem* PriceInfo::mutable_total_room_price() {
  set_has_total_room_price();
  if (total_room_price_ == NULL) total_room_price_ = new ::price::PriceItem;
  return total_room_price_;
}
inline ::price::PriceItem* PriceInfo::release_total_room_price() {
  clear_has_total_room_price();
  ::price::PriceItem* temp = total_room_price_;
  total_room_price_ = NULL;
  return temp;
}

// optional .price.ExtraCharge extra_charge = 4;
inline bool PriceInfo::has_extra_charge() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PriceInfo::set_has_extra_charge() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PriceInfo::clear_has_extra_charge() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PriceInfo::clear_extra_charge() {
  if (extra_charge_ != NULL) extra_charge_->::price::ExtraCharge::Clear();
  clear_has_extra_charge();
}
inline const ::price::ExtraCharge& PriceInfo::extra_charge() const {
  return extra_charge_ != NULL ? *extra_charge_ : *default_instance_->extra_charge_;
}
inline ::price::ExtraCharge* PriceInfo::mutable_extra_charge() {
  set_has_extra_charge();
  if (extra_charge_ == NULL) extra_charge_ = new ::price::ExtraCharge;
  return extra_charge_;
}
inline ::price::ExtraCharge* PriceInfo::release_extra_charge() {
  clear_has_extra_charge();
  ::price::ExtraCharge* temp = extra_charge_;
  extra_charge_ = NULL;
  return temp;
}

// repeated .price.DailyPrice daily_price_list = 5;
inline int PriceInfo::daily_price_list_size() const {
  return daily_price_list_.size();
}
inline void PriceInfo::clear_daily_price_list() {
  daily_price_list_.Clear();
}
inline const ::price::DailyPrice& PriceInfo::daily_price_list(int index) const {
  return daily_price_list_.Get(index);
}
inline ::price::DailyPrice* PriceInfo::mutable_daily_price_list(int index) {
  return daily_price_list_.Mutable(index);
}
inline ::price::DailyPrice* PriceInfo::add_daily_price_list() {
  return daily_price_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::price::DailyPrice >&
PriceInfo::daily_price_list() const {
  return daily_price_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::price::DailyPrice >*
PriceInfo::mutable_daily_price_list() {
  return &daily_price_list_;
}

// optional .price.PriceItem average_price = 6;
inline bool PriceInfo::has_average_price() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PriceInfo::set_has_average_price() {
  _has_bits_[0] |= 0x00000020u;
}
inline void PriceInfo::clear_has_average_price() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void PriceInfo::clear_average_price() {
  if (average_price_ != NULL) average_price_->::price::PriceItem::Clear();
  clear_has_average_price();
}
inline const ::price::PriceItem& PriceInfo::average_price() const {
  return average_price_ != NULL ? *average_price_ : *default_instance_->average_price_;
}
inline ::price::PriceItem* PriceInfo::mutable_average_price() {
  set_has_average_price();
  if (average_price_ == NULL) average_price_ = new ::price::PriceItem;
  return average_price_;
}
inline ::price::PriceItem* PriceInfo::release_average_price() {
  clear_has_average_price();
  ::price::PriceItem* temp = average_price_;
  average_price_ = NULL;
  return temp;
}

// optional .price.PriceItem average_room_price = 7;
inline bool PriceInfo::has_average_room_price() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void PriceInfo::set_has_average_room_price() {
  _has_bits_[0] |= 0x00000040u;
}
inline void PriceInfo::clear_has_average_room_price() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void PriceInfo::clear_average_room_price() {
  if (average_room_price_ != NULL) average_room_price_->::price::PriceItem::Clear();
  clear_has_average_room_price();
}
inline const ::price::PriceItem& PriceInfo::average_room_price() const {
  return average_room_price_ != NULL ? *average_room_price_ : *default_instance_->average_room_price_;
}
inline ::price::PriceItem* PriceInfo::mutable_average_room_price() {
  set_has_average_room_price();
  if (average_room_price_ == NULL) average_room_price_ = new ::price::PriceItem;
  return average_room_price_;
}
inline ::price::PriceItem* PriceInfo::release_average_room_price() {
  clear_has_average_room_price();
  ::price::PriceItem* temp = average_room_price_;
  average_room_price_ = NULL;
  return temp;
}

// optional .price.PriceItem addition_price = 8;
inline bool PriceInfo::has_addition_price() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void PriceInfo::set_has_addition_price() {
  _has_bits_[0] |= 0x00000080u;
}
inline void PriceInfo::clear_has_addition_price() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void PriceInfo::clear_addition_price() {
  if (addition_price_ != NULL) addition_price_->::price::PriceItem::Clear();
  clear_has_addition_price();
}
inline const ::price::PriceItem& PriceInfo::addition_price() const {
  return addition_price_ != NULL ? *addition_price_ : *default_instance_->addition_price_;
}
inline ::price::PriceItem* PriceInfo::mutable_addition_price() {
  set_has_addition_price();
  if (addition_price_ == NULL) addition_price_ = new ::price::PriceItem;
  return addition_price_;
}
inline ::price::PriceItem* PriceInfo::release_addition_price() {
  clear_has_addition_price();
  ::price::PriceItem* temp = addition_price_;
  addition_price_ = NULL;
  return temp;
}

// optional .price.PriceItem sort_price = 9;
inline bool PriceInfo::has_sort_price() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void PriceInfo::set_has_sort_price() {
  _has_bits_[0] |= 0x00000100u;
}
inline void PriceInfo::clear_has_sort_price() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void PriceInfo::clear_sort_price() {
  if (sort_price_ != NULL) sort_price_->::price::PriceItem::Clear();
  clear_has_sort_price();
}
inline const ::price::PriceItem& PriceInfo::sort_price() const {
  return sort_price_ != NULL ? *sort_price_ : *default_instance_->sort_price_;
}
inline ::price::PriceItem* PriceInfo::mutable_sort_price() {
  set_has_sort_price();
  if (sort_price_ == NULL) sort_price_ = new ::price::PriceItem;
  return sort_price_;
}
inline ::price::PriceItem* PriceInfo::release_sort_price() {
  clear_has_sort_price();
  ::price::PriceItem* temp = sort_price_;
  sort_price_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// PersonHold

// required int32 max_person_num = 1;
inline bool PersonHold::has_max_person_num() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PersonHold::set_has_max_person_num() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PersonHold::clear_has_max_person_num() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PersonHold::clear_max_person_num() {
  max_person_num_ = 0;
  clear_has_max_person_num();
}
inline ::google::protobuf::int32 PersonHold::max_person_num() const {
  return max_person_num_;
}
inline void PersonHold::set_max_person_num(::google::protobuf::int32 value) {
  set_has_max_person_num();
  max_person_num_ = value;
}

// optional int32 max_adult_num = 2;
inline bool PersonHold::has_max_adult_num() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PersonHold::set_has_max_adult_num() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PersonHold::clear_has_max_adult_num() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PersonHold::clear_max_adult_num() {
  max_adult_num_ = 0;
  clear_has_max_adult_num();
}
inline ::google::protobuf::int32 PersonHold::max_adult_num() const {
  return max_adult_num_;
}
inline void PersonHold::set_max_adult_num(::google::protobuf::int32 value) {
  set_has_max_adult_num();
  max_adult_num_ = value;
}

// optional int32 max_child_num = 3;
inline bool PersonHold::has_max_child_num() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PersonHold::set_has_max_child_num() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PersonHold::clear_has_max_child_num() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PersonHold::clear_max_child_num() {
  max_child_num_ = 0;
  clear_has_max_child_num();
}
inline ::google::protobuf::int32 PersonHold::max_child_num() const {
  return max_child_num_;
}
inline void PersonHold::set_max_child_num(::google::protobuf::int32 value) {
  set_has_max_child_num();
  max_child_num_ = value;
}

// optional int32 max_child_age = 4;
inline bool PersonHold::has_max_child_age() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PersonHold::set_has_max_child_age() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PersonHold::clear_has_max_child_age() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PersonHold::clear_max_child_age() {
  max_child_age_ = 0;
  clear_has_max_child_age();
}
inline ::google::protobuf::int32 PersonHold::max_child_age() const {
  return max_child_age_;
}
inline void PersonHold::set_max_child_age(::google::protobuf::int32 value) {
  set_has_max_child_age();
  max_child_age_ = value;
}

// optional int32 min_child_alone_age = 5;
inline bool PersonHold::has_min_child_alone_age() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PersonHold::set_has_min_child_alone_age() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PersonHold::clear_has_min_child_alone_age() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PersonHold::clear_min_child_alone_age() {
  min_child_alone_age_ = 0;
  clear_has_min_child_alone_age();
}
inline ::google::protobuf::int32 PersonHold::min_child_alone_age() const {
  return min_child_alone_age_;
}
inline void PersonHold::set_min_child_alone_age(::google::protobuf::int32 value) {
  set_has_min_child_alone_age();
  min_child_alone_age_ = value;
}

// -------------------------------------------------------------------

// Product

// required int64 elong_pid = 1;
inline bool Product::has_elong_pid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Product::set_has_elong_pid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Product::clear_has_elong_pid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Product::clear_elong_pid() {
  elong_pid_ = GOOGLE_LONGLONG(0);
  clear_has_elong_pid();
}
inline ::google::protobuf::int64 Product::elong_pid() const {
  return elong_pid_;
}
inline void Product::set_elong_pid(::google::protobuf::int64 value) {
  set_has_elong_pid();
  elong_pid_ = value;
}

// optional string ota_pid = 3;
inline bool Product::has_ota_pid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Product::set_has_ota_pid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Product::clear_has_ota_pid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Product::clear_ota_pid() {
  if (ota_pid_ != &::google::protobuf::internal::kEmptyString) {
    ota_pid_->clear();
  }
  clear_has_ota_pid();
}
inline const ::std::string& Product::ota_pid() const {
  return *ota_pid_;
}
inline void Product::set_ota_pid(const ::std::string& value) {
  set_has_ota_pid();
  if (ota_pid_ == &::google::protobuf::internal::kEmptyString) {
    ota_pid_ = new ::std::string;
  }
  ota_pid_->assign(value);
}
inline void Product::set_ota_pid(const char* value) {
  set_has_ota_pid();
  if (ota_pid_ == &::google::protobuf::internal::kEmptyString) {
    ota_pid_ = new ::std::string;
  }
  ota_pid_->assign(value);
}
inline void Product::set_ota_pid(const char* value, size_t size) {
  set_has_ota_pid();
  if (ota_pid_ == &::google::protobuf::internal::kEmptyString) {
    ota_pid_ = new ::std::string;
  }
  ota_pid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Product::mutable_ota_pid() {
  set_has_ota_pid();
  if (ota_pid_ == &::google::protobuf::internal::kEmptyString) {
    ota_pid_ = new ::std::string;
  }
  return ota_pid_;
}
inline ::std::string* Product::release_ota_pid() {
  clear_has_ota_pid();
  if (ota_pid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ota_pid_;
    ota_pid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bytes product_name_cn = 4;
inline bool Product::has_product_name_cn() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Product::set_has_product_name_cn() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Product::clear_has_product_name_cn() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Product::clear_product_name_cn() {
  if (product_name_cn_ != &::google::protobuf::internal::kEmptyString) {
    product_name_cn_->clear();
  }
  clear_has_product_name_cn();
}
inline const ::std::string& Product::product_name_cn() const {
  return *product_name_cn_;
}
inline void Product::set_product_name_cn(const ::std::string& value) {
  set_has_product_name_cn();
  if (product_name_cn_ == &::google::protobuf::internal::kEmptyString) {
    product_name_cn_ = new ::std::string;
  }
  product_name_cn_->assign(value);
}
inline void Product::set_product_name_cn(const char* value) {
  set_has_product_name_cn();
  if (product_name_cn_ == &::google::protobuf::internal::kEmptyString) {
    product_name_cn_ = new ::std::string;
  }
  product_name_cn_->assign(value);
}
inline void Product::set_product_name_cn(const void* value, size_t size) {
  set_has_product_name_cn();
  if (product_name_cn_ == &::google::protobuf::internal::kEmptyString) {
    product_name_cn_ = new ::std::string;
  }
  product_name_cn_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Product::mutable_product_name_cn() {
  set_has_product_name_cn();
  if (product_name_cn_ == &::google::protobuf::internal::kEmptyString) {
    product_name_cn_ = new ::std::string;
  }
  return product_name_cn_;
}
inline ::std::string* Product::release_product_name_cn() {
  clear_has_product_name_cn();
  if (product_name_cn_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = product_name_cn_;
    product_name_cn_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bytes product_name_en = 5;
inline bool Product::has_product_name_en() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Product::set_has_product_name_en() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Product::clear_has_product_name_en() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Product::clear_product_name_en() {
  if (product_name_en_ != &::google::protobuf::internal::kEmptyString) {
    product_name_en_->clear();
  }
  clear_has_product_name_en();
}
inline const ::std::string& Product::product_name_en() const {
  return *product_name_en_;
}
inline void Product::set_product_name_en(const ::std::string& value) {
  set_has_product_name_en();
  if (product_name_en_ == &::google::protobuf::internal::kEmptyString) {
    product_name_en_ = new ::std::string;
  }
  product_name_en_->assign(value);
}
inline void Product::set_product_name_en(const char* value) {
  set_has_product_name_en();
  if (product_name_en_ == &::google::protobuf::internal::kEmptyString) {
    product_name_en_ = new ::std::string;
  }
  product_name_en_->assign(value);
}
inline void Product::set_product_name_en(const void* value, size_t size) {
  set_has_product_name_en();
  if (product_name_en_ == &::google::protobuf::internal::kEmptyString) {
    product_name_en_ = new ::std::string;
  }
  product_name_en_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Product::mutable_product_name_en() {
  set_has_product_name_en();
  if (product_name_en_ == &::google::protobuf::internal::kEmptyString) {
    product_name_en_ = new ::std::string;
  }
  return product_name_en_;
}
inline ::std::string* Product::release_product_name_en() {
  clear_has_product_name_en();
  if (product_name_en_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = product_name_en_;
    product_name_en_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional .price.RatePlan rateplan = 6;
inline bool Product::has_rateplan() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Product::set_has_rateplan() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Product::clear_has_rateplan() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Product::clear_rateplan() {
  if (rateplan_ != NULL) rateplan_->::price::RatePlan::Clear();
  clear_has_rateplan();
}
inline const ::price::RatePlan& Product::rateplan() const {
  return rateplan_ != NULL ? *rateplan_ : *default_instance_->rateplan_;
}
inline ::price::RatePlan* Product::mutable_rateplan() {
  set_has_rateplan();
  if (rateplan_ == NULL) rateplan_ = new ::price::RatePlan;
  return rateplan_;
}
inline ::price::RatePlan* Product::release_rateplan() {
  clear_has_rateplan();
  ::price::RatePlan* temp = rateplan_;
  rateplan_ = NULL;
  return temp;
}

// optional .price.ProductDesc product_desc = 8;
inline bool Product::has_product_desc() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Product::set_has_product_desc() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Product::clear_has_product_desc() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Product::clear_product_desc() {
  if (product_desc_ != NULL) product_desc_->::price::ProductDesc::Clear();
  clear_has_product_desc();
}
inline const ::price::ProductDesc& Product::product_desc() const {
  return product_desc_ != NULL ? *product_desc_ : *default_instance_->product_desc_;
}
inline ::price::ProductDesc* Product::mutable_product_desc() {
  set_has_product_desc();
  if (product_desc_ == NULL) product_desc_ = new ::price::ProductDesc;
  return product_desc_;
}
inline ::price::ProductDesc* Product::release_product_desc() {
  clear_has_product_desc();
  ::price::ProductDesc* temp = product_desc_;
  product_desc_ = NULL;
  return temp;
}

// required int32 room_num = 9;
inline bool Product::has_room_num() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Product::set_has_room_num() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Product::clear_has_room_num() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Product::clear_room_num() {
  room_num_ = 0;
  clear_has_room_num();
}
inline ::google::protobuf::int32 Product::room_num() const {
  return room_num_;
}
inline void Product::set_room_num(::google::protobuf::int32 value) {
  set_has_room_num();
  room_num_ = value;
}

// repeated .price.PromotionInfo promotion_info = 10;
inline int Product::promotion_info_size() const {
  return promotion_info_.size();
}
inline void Product::clear_promotion_info() {
  promotion_info_.Clear();
}
inline const ::price::PromotionInfo& Product::promotion_info(int index) const {
  return promotion_info_.Get(index);
}
inline ::price::PromotionInfo* Product::mutable_promotion_info(int index) {
  return promotion_info_.Mutable(index);
}
inline ::price::PromotionInfo* Product::add_promotion_info() {
  return promotion_info_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::price::PromotionInfo >&
Product::promotion_info() const {
  return promotion_info_;
}
inline ::google::protobuf::RepeatedPtrField< ::price::PromotionInfo >*
Product::mutable_promotion_info() {
  return &promotion_info_;
}

// optional .price.ProductFilter product_filter = 11;
inline bool Product::has_product_filter() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Product::set_has_product_filter() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Product::clear_has_product_filter() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Product::clear_product_filter() {
  if (product_filter_ != NULL) product_filter_->::price::ProductFilter::Clear();
  clear_has_product_filter();
}
inline const ::price::ProductFilter& Product::product_filter() const {
  return product_filter_ != NULL ? *product_filter_ : *default_instance_->product_filter_;
}
inline ::price::ProductFilter* Product::mutable_product_filter() {
  set_has_product_filter();
  if (product_filter_ == NULL) product_filter_ = new ::price::ProductFilter;
  return product_filter_;
}
inline ::price::ProductFilter* Product::release_product_filter() {
  clear_has_product_filter();
  ::price::ProductFilter* temp = product_filter_;
  product_filter_ = NULL;
  return temp;
}

// optional string attachment = 12;
inline bool Product::has_attachment() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Product::set_has_attachment() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Product::clear_has_attachment() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Product::clear_attachment() {
  if (attachment_ != &::google::protobuf::internal::kEmptyString) {
    attachment_->clear();
  }
  clear_has_attachment();
}
inline const ::std::string& Product::attachment() const {
  return *attachment_;
}
inline void Product::set_attachment(const ::std::string& value) {
  set_has_attachment();
  if (attachment_ == &::google::protobuf::internal::kEmptyString) {
    attachment_ = new ::std::string;
  }
  attachment_->assign(value);
}
inline void Product::set_attachment(const char* value) {
  set_has_attachment();
  if (attachment_ == &::google::protobuf::internal::kEmptyString) {
    attachment_ = new ::std::string;
  }
  attachment_->assign(value);
}
inline void Product::set_attachment(const char* value, size_t size) {
  set_has_attachment();
  if (attachment_ == &::google::protobuf::internal::kEmptyString) {
    attachment_ = new ::std::string;
  }
  attachment_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Product::mutable_attachment() {
  set_has_attachment();
  if (attachment_ == &::google::protobuf::internal::kEmptyString) {
    attachment_ = new ::std::string;
  }
  return attachment_;
}
inline ::std::string* Product::release_attachment() {
  clear_has_attachment();
  if (attachment_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = attachment_;
    attachment_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional .price.PriceInfo booking_price = 20;
inline bool Product::has_booking_price() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Product::set_has_booking_price() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Product::clear_has_booking_price() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Product::clear_booking_price() {
  if (booking_price_ != NULL) booking_price_->::price::PriceInfo::Clear();
  clear_has_booking_price();
}
inline const ::price::PriceInfo& Product::booking_price() const {
  return booking_price_ != NULL ? *booking_price_ : *default_instance_->booking_price_;
}
inline ::price::PriceInfo* Product::mutable_booking_price() {
  set_has_booking_price();
  if (booking_price_ == NULL) booking_price_ = new ::price::PriceInfo;
  return booking_price_;
}
inline ::price::PriceInfo* Product::release_booking_price() {
  clear_has_booking_price();
  ::price::PriceInfo* temp = booking_price_;
  booking_price_ = NULL;
  return temp;
}

// optional .price.PriceInfo cost_price = 21;
inline bool Product::has_cost_price() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Product::set_has_cost_price() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Product::clear_has_cost_price() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Product::clear_cost_price() {
  if (cost_price_ != NULL) cost_price_->::price::PriceInfo::Clear();
  clear_has_cost_price();
}
inline const ::price::PriceInfo& Product::cost_price() const {
  return cost_price_ != NULL ? *cost_price_ : *default_instance_->cost_price_;
}
inline ::price::PriceInfo* Product::mutable_cost_price() {
  set_has_cost_price();
  if (cost_price_ == NULL) cost_price_ = new ::price::PriceInfo;
  return cost_price_;
}
inline ::price::PriceInfo* Product::release_cost_price() {
  clear_has_cost_price();
  ::price::PriceInfo* temp = cost_price_;
  cost_price_ = NULL;
  return temp;
}

// optional .price.PriceInfo origin_price = 22;
inline bool Product::has_origin_price() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void Product::set_has_origin_price() {
  _has_bits_[0] |= 0x00001000u;
}
inline void Product::clear_has_origin_price() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void Product::clear_origin_price() {
  if (origin_price_ != NULL) origin_price_->::price::PriceInfo::Clear();
  clear_has_origin_price();
}
inline const ::price::PriceInfo& Product::origin_price() const {
  return origin_price_ != NULL ? *origin_price_ : *default_instance_->origin_price_;
}
inline ::price::PriceInfo* Product::mutable_origin_price() {
  set_has_origin_price();
  if (origin_price_ == NULL) origin_price_ = new ::price::PriceInfo;
  return origin_price_;
}
inline ::price::PriceInfo* Product::release_origin_price() {
  clear_has_origin_price();
  ::price::PriceInfo* temp = origin_price_;
  origin_price_ = NULL;
  return temp;
}

// optional .price.PriceInfo sale_price = 23;
inline bool Product::has_sale_price() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void Product::set_has_sale_price() {
  _has_bits_[0] |= 0x00002000u;
}
inline void Product::clear_has_sale_price() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void Product::clear_sale_price() {
  if (sale_price_ != NULL) sale_price_->::price::PriceInfo::Clear();
  clear_has_sale_price();
}
inline const ::price::PriceInfo& Product::sale_price() const {
  return sale_price_ != NULL ? *sale_price_ : *default_instance_->sale_price_;
}
inline ::price::PriceInfo* Product::mutable_sale_price() {
  set_has_sale_price();
  if (sale_price_ == NULL) sale_price_ = new ::price::PriceInfo;
  return sale_price_;
}
inline ::price::PriceInfo* Product::release_sale_price() {
  clear_has_sale_price();
  ::price::PriceInfo* temp = sale_price_;
  sale_price_ = NULL;
  return temp;
}

// optional int32 source_ota_id = 50 [default = -1];
inline bool Product::has_source_ota_id() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void Product::set_has_source_ota_id() {
  _has_bits_[0] |= 0x00004000u;
}
inline void Product::clear_has_source_ota_id() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void Product::clear_source_ota_id() {
  source_ota_id_ = -1;
  clear_has_source_ota_id();
}
inline ::google::protobuf::int32 Product::source_ota_id() const {
  return source_ota_id_;
}
inline void Product::set_source_ota_id(::google::protobuf::int32 value) {
  set_has_source_ota_id();
  source_ota_id_ = value;
}

// optional int64 ota_sign = 51;
inline bool Product::has_ota_sign() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void Product::set_has_ota_sign() {
  _has_bits_[0] |= 0x00008000u;
}
inline void Product::clear_has_ota_sign() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void Product::clear_ota_sign() {
  ota_sign_ = GOOGLE_LONGLONG(0);
  clear_has_ota_sign();
}
inline ::google::protobuf::int64 Product::ota_sign() const {
  return ota_sign_;
}
inline void Product::set_ota_sign(::google::protobuf::int64 value) {
  set_has_ota_sign();
  ota_sign_ = value;
}

// repeated .price.Tag tag = 24;
inline int Product::tag_size() const {
  return tag_.size();
}
inline void Product::clear_tag() {
  tag_.Clear();
}
inline const ::price::Tag& Product::tag(int index) const {
  return tag_.Get(index);
}
inline ::price::Tag* Product::mutable_tag(int index) {
  return tag_.Mutable(index);
}
inline ::price::Tag* Product::add_tag() {
  return tag_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::price::Tag >&
Product::tag() const {
  return tag_;
}
inline ::google::protobuf::RepeatedPtrField< ::price::Tag >*
Product::mutable_tag() {
  return &tag_;
}

// -------------------------------------------------------------------

// Room

// optional int64 mroom_id = 1;
inline bool Room::has_mroom_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Room::set_has_mroom_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Room::clear_has_mroom_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Room::clear_mroom_id() {
  mroom_id_ = GOOGLE_LONGLONG(0);
  clear_has_mroom_id();
}
inline ::google::protobuf::int64 Room::mroom_id() const {
  return mroom_id_;
}
inline void Room::set_mroom_id(::google::protobuf::int64 value) {
  set_has_mroom_id();
  mroom_id_ = value;
}

// optional bytes mroom_name_cn = 2;
inline bool Room::has_mroom_name_cn() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Room::set_has_mroom_name_cn() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Room::clear_has_mroom_name_cn() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Room::clear_mroom_name_cn() {
  if (mroom_name_cn_ != &::google::protobuf::internal::kEmptyString) {
    mroom_name_cn_->clear();
  }
  clear_has_mroom_name_cn();
}
inline const ::std::string& Room::mroom_name_cn() const {
  return *mroom_name_cn_;
}
inline void Room::set_mroom_name_cn(const ::std::string& value) {
  set_has_mroom_name_cn();
  if (mroom_name_cn_ == &::google::protobuf::internal::kEmptyString) {
    mroom_name_cn_ = new ::std::string;
  }
  mroom_name_cn_->assign(value);
}
inline void Room::set_mroom_name_cn(const char* value) {
  set_has_mroom_name_cn();
  if (mroom_name_cn_ == &::google::protobuf::internal::kEmptyString) {
    mroom_name_cn_ = new ::std::string;
  }
  mroom_name_cn_->assign(value);
}
inline void Room::set_mroom_name_cn(const void* value, size_t size) {
  set_has_mroom_name_cn();
  if (mroom_name_cn_ == &::google::protobuf::internal::kEmptyString) {
    mroom_name_cn_ = new ::std::string;
  }
  mroom_name_cn_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Room::mutable_mroom_name_cn() {
  set_has_mroom_name_cn();
  if (mroom_name_cn_ == &::google::protobuf::internal::kEmptyString) {
    mroom_name_cn_ = new ::std::string;
  }
  return mroom_name_cn_;
}
inline ::std::string* Room::release_mroom_name_cn() {
  clear_has_mroom_name_cn();
  if (mroom_name_cn_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = mroom_name_cn_;
    mroom_name_cn_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bytes mroom_name_en = 3;
inline bool Room::has_mroom_name_en() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Room::set_has_mroom_name_en() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Room::clear_has_mroom_name_en() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Room::clear_mroom_name_en() {
  if (mroom_name_en_ != &::google::protobuf::internal::kEmptyString) {
    mroom_name_en_->clear();
  }
  clear_has_mroom_name_en();
}
inline const ::std::string& Room::mroom_name_en() const {
  return *mroom_name_en_;
}
inline void Room::set_mroom_name_en(const ::std::string& value) {
  set_has_mroom_name_en();
  if (mroom_name_en_ == &::google::protobuf::internal::kEmptyString) {
    mroom_name_en_ = new ::std::string;
  }
  mroom_name_en_->assign(value);
}
inline void Room::set_mroom_name_en(const char* value) {
  set_has_mroom_name_en();
  if (mroom_name_en_ == &::google::protobuf::internal::kEmptyString) {
    mroom_name_en_ = new ::std::string;
  }
  mroom_name_en_->assign(value);
}
inline void Room::set_mroom_name_en(const void* value, size_t size) {
  set_has_mroom_name_en();
  if (mroom_name_en_ == &::google::protobuf::internal::kEmptyString) {
    mroom_name_en_ = new ::std::string;
  }
  mroom_name_en_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Room::mutable_mroom_name_en() {
  set_has_mroom_name_en();
  if (mroom_name_en_ == &::google::protobuf::internal::kEmptyString) {
    mroom_name_en_ = new ::std::string;
  }
  return mroom_name_en_;
}
inline ::std::string* Room::release_mroom_name_en() {
  clear_has_mroom_name_en();
  if (mroom_name_en_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = mroom_name_en_;
    mroom_name_en_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required int64 room_id = 4;
inline bool Room::has_room_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Room::set_has_room_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Room::clear_has_room_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Room::clear_room_id() {
  room_id_ = GOOGLE_LONGLONG(0);
  clear_has_room_id();
}
inline ::google::protobuf::int64 Room::room_id() const {
  return room_id_;
}
inline void Room::set_room_id(::google::protobuf::int64 value) {
  set_has_room_id();
  room_id_ = value;
}

// required bytes room_name_cn = 5;
inline bool Room::has_room_name_cn() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Room::set_has_room_name_cn() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Room::clear_has_room_name_cn() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Room::clear_room_name_cn() {
  if (room_name_cn_ != &::google::protobuf::internal::kEmptyString) {
    room_name_cn_->clear();
  }
  clear_has_room_name_cn();
}
inline const ::std::string& Room::room_name_cn() const {
  return *room_name_cn_;
}
inline void Room::set_room_name_cn(const ::std::string& value) {
  set_has_room_name_cn();
  if (room_name_cn_ == &::google::protobuf::internal::kEmptyString) {
    room_name_cn_ = new ::std::string;
  }
  room_name_cn_->assign(value);
}
inline void Room::set_room_name_cn(const char* value) {
  set_has_room_name_cn();
  if (room_name_cn_ == &::google::protobuf::internal::kEmptyString) {
    room_name_cn_ = new ::std::string;
  }
  room_name_cn_->assign(value);
}
inline void Room::set_room_name_cn(const void* value, size_t size) {
  set_has_room_name_cn();
  if (room_name_cn_ == &::google::protobuf::internal::kEmptyString) {
    room_name_cn_ = new ::std::string;
  }
  room_name_cn_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Room::mutable_room_name_cn() {
  set_has_room_name_cn();
  if (room_name_cn_ == &::google::protobuf::internal::kEmptyString) {
    room_name_cn_ = new ::std::string;
  }
  return room_name_cn_;
}
inline ::std::string* Room::release_room_name_cn() {
  clear_has_room_name_cn();
  if (room_name_cn_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = room_name_cn_;
    room_name_cn_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bytes room_name_en = 6;
inline bool Room::has_room_name_en() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Room::set_has_room_name_en() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Room::clear_has_room_name_en() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Room::clear_room_name_en() {
  if (room_name_en_ != &::google::protobuf::internal::kEmptyString) {
    room_name_en_->clear();
  }
  clear_has_room_name_en();
}
inline const ::std::string& Room::room_name_en() const {
  return *room_name_en_;
}
inline void Room::set_room_name_en(const ::std::string& value) {
  set_has_room_name_en();
  if (room_name_en_ == &::google::protobuf::internal::kEmptyString) {
    room_name_en_ = new ::std::string;
  }
  room_name_en_->assign(value);
}
inline void Room::set_room_name_en(const char* value) {
  set_has_room_name_en();
  if (room_name_en_ == &::google::protobuf::internal::kEmptyString) {
    room_name_en_ = new ::std::string;
  }
  room_name_en_->assign(value);
}
inline void Room::set_room_name_en(const void* value, size_t size) {
  set_has_room_name_en();
  if (room_name_en_ == &::google::protobuf::internal::kEmptyString) {
    room_name_en_ = new ::std::string;
  }
  room_name_en_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Room::mutable_room_name_en() {
  set_has_room_name_en();
  if (room_name_en_ == &::google::protobuf::internal::kEmptyString) {
    room_name_en_ = new ::std::string;
  }
  return room_name_en_;
}
inline ::std::string* Room::release_room_name_en() {
  clear_has_room_name_en();
  if (room_name_en_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = room_name_en_;
    room_name_en_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required int32 room_status = 7;
inline bool Room::has_room_status() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Room::set_has_room_status() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Room::clear_has_room_status() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Room::clear_room_status() {
  room_status_ = 0;
  clear_has_room_status();
}
inline ::google::protobuf::int32 Room::room_status() const {
  return room_status_;
}
inline void Room::set_room_status(::google::protobuf::int32 value) {
  set_has_room_status();
  room_status_ = value;
}

// optional int32 allotment = 8 [default = -1];
inline bool Room::has_allotment() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Room::set_has_allotment() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Room::clear_has_allotment() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Room::clear_allotment() {
  allotment_ = -1;
  clear_has_allotment();
}
inline ::google::protobuf::int32 Room::allotment() const {
  return allotment_;
}
inline void Room::set_allotment(::google::protobuf::int32 value) {
  set_has_allotment();
  allotment_ = value;
}

// optional .price.PersonHold person_hold = 9;
inline bool Room::has_person_hold() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Room::set_has_person_hold() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Room::clear_has_person_hold() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Room::clear_person_hold() {
  if (person_hold_ != NULL) person_hold_->::price::PersonHold::Clear();
  clear_has_person_hold();
}
inline const ::price::PersonHold& Room::person_hold() const {
  return person_hold_ != NULL ? *person_hold_ : *default_instance_->person_hold_;
}
inline ::price::PersonHold* Room::mutable_person_hold() {
  set_has_person_hold();
  if (person_hold_ == NULL) person_hold_ = new ::price::PersonHold;
  return person_hold_;
}
inline ::price::PersonHold* Room::release_person_hold() {
  clear_has_person_hold();
  ::price::PersonHold* temp = person_hold_;
  person_hold_ = NULL;
  return temp;
}

// optional .price.RoomDesc room_desc = 10;
inline bool Room::has_room_desc() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Room::set_has_room_desc() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Room::clear_has_room_desc() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Room::clear_room_desc() {
  if (room_desc_ != NULL) room_desc_->::price::RoomDesc::Clear();
  clear_has_room_desc();
}
inline const ::price::RoomDesc& Room::room_desc() const {
  return room_desc_ != NULL ? *room_desc_ : *default_instance_->room_desc_;
}
inline ::price::RoomDesc* Room::mutable_room_desc() {
  set_has_room_desc();
  if (room_desc_ == NULL) room_desc_ = new ::price::RoomDesc;
  return room_desc_;
}
inline ::price::RoomDesc* Room::release_room_desc() {
  clear_has_room_desc();
  ::price::RoomDesc* temp = room_desc_;
  room_desc_ = NULL;
  return temp;
}

// optional string attachment = 11;
inline bool Room::has_attachment() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Room::set_has_attachment() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Room::clear_has_attachment() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Room::clear_attachment() {
  if (attachment_ != &::google::protobuf::internal::kEmptyString) {
    attachment_->clear();
  }
  clear_has_attachment();
}
inline const ::std::string& Room::attachment() const {
  return *attachment_;
}
inline void Room::set_attachment(const ::std::string& value) {
  set_has_attachment();
  if (attachment_ == &::google::protobuf::internal::kEmptyString) {
    attachment_ = new ::std::string;
  }
  attachment_->assign(value);
}
inline void Room::set_attachment(const char* value) {
  set_has_attachment();
  if (attachment_ == &::google::protobuf::internal::kEmptyString) {
    attachment_ = new ::std::string;
  }
  attachment_->assign(value);
}
inline void Room::set_attachment(const char* value, size_t size) {
  set_has_attachment();
  if (attachment_ == &::google::protobuf::internal::kEmptyString) {
    attachment_ = new ::std::string;
  }
  attachment_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Room::mutable_attachment() {
  set_has_attachment();
  if (attachment_ == &::google::protobuf::internal::kEmptyString) {
    attachment_ = new ::std::string;
  }
  return attachment_;
}
inline ::std::string* Room::release_attachment() {
  clear_has_attachment();
  if (attachment_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = attachment_;
    attachment_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated .price.Product product_list = 12;
inline int Room::product_list_size() const {
  return product_list_.size();
}
inline void Room::clear_product_list() {
  product_list_.Clear();
}
inline const ::price::Product& Room::product_list(int index) const {
  return product_list_.Get(index);
}
inline ::price::Product* Room::mutable_product_list(int index) {
  return product_list_.Mutable(index);
}
inline ::price::Product* Room::add_product_list() {
  return product_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::price::Product >&
Room::product_list() const {
  return product_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::price::Product >*
Room::mutable_product_list() {
  return &product_list_;
}

// optional .price.PriceInfo base_price = 21;
inline bool Room::has_base_price() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void Room::set_has_base_price() {
  _has_bits_[0] |= 0x00001000u;
}
inline void Room::clear_has_base_price() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void Room::clear_base_price() {
  if (base_price_ != NULL) base_price_->::price::PriceInfo::Clear();
  clear_has_base_price();
}
inline const ::price::PriceInfo& Room::base_price() const {
  return base_price_ != NULL ? *base_price_ : *default_instance_->base_price_;
}
inline ::price::PriceInfo* Room::mutable_base_price() {
  set_has_base_price();
  if (base_price_ == NULL) base_price_ = new ::price::PriceInfo;
  return base_price_;
}
inline ::price::PriceInfo* Room::release_base_price() {
  clear_has_base_price();
  ::price::PriceInfo* temp = base_price_;
  base_price_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// DetailOta

// required int32 base_hotel_id = 1;
inline bool DetailOta::has_base_hotel_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DetailOta::set_has_base_hotel_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DetailOta::clear_has_base_hotel_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DetailOta::clear_base_hotel_id() {
  base_hotel_id_ = 0;
  clear_has_base_hotel_id();
}
inline ::google::protobuf::int32 DetailOta::base_hotel_id() const {
  return base_hotel_id_;
}
inline void DetailOta::set_base_hotel_id(::google::protobuf::int32 value) {
  set_has_base_hotel_id();
  base_hotel_id_ = value;
}

// optional int64 crawl_time = 2;
inline bool DetailOta::has_crawl_time() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DetailOta::set_has_crawl_time() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DetailOta::clear_has_crawl_time() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DetailOta::clear_crawl_time() {
  crawl_time_ = GOOGLE_LONGLONG(0);
  clear_has_crawl_time();
}
inline ::google::protobuf::int64 DetailOta::crawl_time() const {
  return crawl_time_;
}
inline void DetailOta::set_crawl_time(::google::protobuf::int64 value) {
  set_has_crawl_time();
  crawl_time_ = value;
}

// optional .price.PriceInfo base_price = 3;
inline bool DetailOta::has_base_price() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DetailOta::set_has_base_price() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DetailOta::clear_has_base_price() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DetailOta::clear_base_price() {
  if (base_price_ != NULL) base_price_->::price::PriceInfo::Clear();
  clear_has_base_price();
}
inline const ::price::PriceInfo& DetailOta::base_price() const {
  return base_price_ != NULL ? *base_price_ : *default_instance_->base_price_;
}
inline ::price::PriceInfo* DetailOta::mutable_base_price() {
  set_has_base_price();
  if (base_price_ == NULL) base_price_ = new ::price::PriceInfo;
  return base_price_;
}
inline ::price::PriceInfo* DetailOta::release_base_price() {
  clear_has_base_price();
  ::price::PriceInfo* temp = base_price_;
  base_price_ = NULL;
  return temp;
}

// repeated .price.PromotionInfo promotion_info = 4;
inline int DetailOta::promotion_info_size() const {
  return promotion_info_.size();
}
inline void DetailOta::clear_promotion_info() {
  promotion_info_.Clear();
}
inline const ::price::PromotionInfo& DetailOta::promotion_info(int index) const {
  return promotion_info_.Get(index);
}
inline ::price::PromotionInfo* DetailOta::mutable_promotion_info(int index) {
  return promotion_info_.Mutable(index);
}
inline ::price::PromotionInfo* DetailOta::add_promotion_info() {
  return promotion_info_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::price::PromotionInfo >&
DetailOta::promotion_info() const {
  return promotion_info_;
}
inline ::google::protobuf::RepeatedPtrField< ::price::PromotionInfo >*
DetailOta::mutable_promotion_info() {
  return &promotion_info_;
}

// required int32 ota_id = 11;
inline bool DetailOta::has_ota_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void DetailOta::set_has_ota_id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void DetailOta::clear_has_ota_id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void DetailOta::clear_ota_id() {
  ota_id_ = 0;
  clear_has_ota_id();
}
inline ::google::protobuf::int32 DetailOta::ota_id() const {
  return ota_id_;
}
inline void DetailOta::set_ota_id(::google::protobuf::int32 value) {
  set_has_ota_id();
  ota_id_ = value;
}

// optional string ota_hotel_id = 12;
inline bool DetailOta::has_ota_hotel_id() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void DetailOta::set_has_ota_hotel_id() {
  _has_bits_[0] |= 0x00000020u;
}
inline void DetailOta::clear_has_ota_hotel_id() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void DetailOta::clear_ota_hotel_id() {
  if (ota_hotel_id_ != &::google::protobuf::internal::kEmptyString) {
    ota_hotel_id_->clear();
  }
  clear_has_ota_hotel_id();
}
inline const ::std::string& DetailOta::ota_hotel_id() const {
  return *ota_hotel_id_;
}
inline void DetailOta::set_ota_hotel_id(const ::std::string& value) {
  set_has_ota_hotel_id();
  if (ota_hotel_id_ == &::google::protobuf::internal::kEmptyString) {
    ota_hotel_id_ = new ::std::string;
  }
  ota_hotel_id_->assign(value);
}
inline void DetailOta::set_ota_hotel_id(const char* value) {
  set_has_ota_hotel_id();
  if (ota_hotel_id_ == &::google::protobuf::internal::kEmptyString) {
    ota_hotel_id_ = new ::std::string;
  }
  ota_hotel_id_->assign(value);
}
inline void DetailOta::set_ota_hotel_id(const char* value, size_t size) {
  set_has_ota_hotel_id();
  if (ota_hotel_id_ == &::google::protobuf::internal::kEmptyString) {
    ota_hotel_id_ = new ::std::string;
  }
  ota_hotel_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DetailOta::mutable_ota_hotel_id() {
  set_has_ota_hotel_id();
  if (ota_hotel_id_ == &::google::protobuf::internal::kEmptyString) {
    ota_hotel_id_ = new ::std::string;
  }
  return ota_hotel_id_;
}
inline ::std::string* DetailOta::release_ota_hotel_id() {
  clear_has_ota_hotel_id();
  if (ota_hotel_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ota_hotel_id_;
    ota_hotel_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required .price.HotelStatus hotel_status = 13;
inline bool DetailOta::has_hotel_status() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void DetailOta::set_has_hotel_status() {
  _has_bits_[0] |= 0x00000040u;
}
inline void DetailOta::clear_has_hotel_status() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void DetailOta::clear_hotel_status() {
  hotel_status_ = 1;
  clear_has_hotel_status();
}
inline price::HotelStatus DetailOta::hotel_status() const {
  return static_cast< price::HotelStatus >(hotel_status_);
}
inline void DetailOta::set_hotel_status(price::HotelStatus value) {
  GOOGLE_DCHECK(price::HotelStatus_IsValid(value));
  set_has_hotel_status();
  hotel_status_ = value;
}

// optional string attachment = 14;
inline bool DetailOta::has_attachment() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void DetailOta::set_has_attachment() {
  _has_bits_[0] |= 0x00000080u;
}
inline void DetailOta::clear_has_attachment() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void DetailOta::clear_attachment() {
  if (attachment_ != &::google::protobuf::internal::kEmptyString) {
    attachment_->clear();
  }
  clear_has_attachment();
}
inline const ::std::string& DetailOta::attachment() const {
  return *attachment_;
}
inline void DetailOta::set_attachment(const ::std::string& value) {
  set_has_attachment();
  if (attachment_ == &::google::protobuf::internal::kEmptyString) {
    attachment_ = new ::std::string;
  }
  attachment_->assign(value);
}
inline void DetailOta::set_attachment(const char* value) {
  set_has_attachment();
  if (attachment_ == &::google::protobuf::internal::kEmptyString) {
    attachment_ = new ::std::string;
  }
  attachment_->assign(value);
}
inline void DetailOta::set_attachment(const char* value, size_t size) {
  set_has_attachment();
  if (attachment_ == &::google::protobuf::internal::kEmptyString) {
    attachment_ = new ::std::string;
  }
  attachment_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DetailOta::mutable_attachment() {
  set_has_attachment();
  if (attachment_ == &::google::protobuf::internal::kEmptyString) {
    attachment_ = new ::std::string;
  }
  return attachment_;
}
inline ::std::string* DetailOta::release_attachment() {
  clear_has_attachment();
  if (attachment_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = attachment_;
    attachment_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated .price.Room room_list = 15;
inline int DetailOta::room_list_size() const {
  return room_list_.size();
}
inline void DetailOta::clear_room_list() {
  room_list_.Clear();
}
inline const ::price::Room& DetailOta::room_list(int index) const {
  return room_list_.Get(index);
}
inline ::price::Room* DetailOta::mutable_room_list(int index) {
  return room_list_.Mutable(index);
}
inline ::price::Room* DetailOta::add_room_list() {
  return room_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::price::Room >&
DetailOta::room_list() const {
  return room_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::price::Room >*
DetailOta::mutable_room_list() {
  return &room_list_;
}

// -------------------------------------------------------------------

// DetailHotel

// required int32 base_hotel_id = 1;
inline bool DetailHotel::has_base_hotel_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DetailHotel::set_has_base_hotel_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DetailHotel::clear_has_base_hotel_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DetailHotel::clear_base_hotel_id() {
  base_hotel_id_ = 0;
  clear_has_base_hotel_id();
}
inline ::google::protobuf::int32 DetailHotel::base_hotel_id() const {
  return base_hotel_id_;
}
inline void DetailHotel::set_base_hotel_id(::google::protobuf::int32 value) {
  set_has_base_hotel_id();
  base_hotel_id_ = value;
}

// optional int64 crawl_time = 2;
inline bool DetailHotel::has_crawl_time() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DetailHotel::set_has_crawl_time() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DetailHotel::clear_has_crawl_time() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DetailHotel::clear_crawl_time() {
  crawl_time_ = GOOGLE_LONGLONG(0);
  clear_has_crawl_time();
}
inline ::google::protobuf::int64 DetailHotel::crawl_time() const {
  return crawl_time_;
}
inline void DetailHotel::set_crawl_time(::google::protobuf::int64 value) {
  set_has_crawl_time();
  crawl_time_ = value;
}

// repeated .price.PromotionInfo promotion_info = 4;
inline int DetailHotel::promotion_info_size() const {
  return promotion_info_.size();
}
inline void DetailHotel::clear_promotion_info() {
  promotion_info_.Clear();
}
inline const ::price::PromotionInfo& DetailHotel::promotion_info(int index) const {
  return promotion_info_.Get(index);
}
inline ::price::PromotionInfo* DetailHotel::mutable_promotion_info(int index) {
  return promotion_info_.Mutable(index);
}
inline ::price::PromotionInfo* DetailHotel::add_promotion_info() {
  return promotion_info_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::price::PromotionInfo >&
DetailHotel::promotion_info() const {
  return promotion_info_;
}
inline ::google::protobuf::RepeatedPtrField< ::price::PromotionInfo >*
DetailHotel::mutable_promotion_info() {
  return &promotion_info_;
}

// optional .price.ProductFilterStat product_filter_stat = 5;
inline bool DetailHotel::has_product_filter_stat() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DetailHotel::set_has_product_filter_stat() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DetailHotel::clear_has_product_filter_stat() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DetailHotel::clear_product_filter_stat() {
  if (product_filter_stat_ != NULL) product_filter_stat_->::price::ProductFilterStat::Clear();
  clear_has_product_filter_stat();
}
inline const ::price::ProductFilterStat& DetailHotel::product_filter_stat() const {
  return product_filter_stat_ != NULL ? *product_filter_stat_ : *default_instance_->product_filter_stat_;
}
inline ::price::ProductFilterStat* DetailHotel::mutable_product_filter_stat() {
  set_has_product_filter_stat();
  if (product_filter_stat_ == NULL) product_filter_stat_ = new ::price::ProductFilterStat;
  return product_filter_stat_;
}
inline ::price::ProductFilterStat* DetailHotel::release_product_filter_stat() {
  clear_has_product_filter_stat();
  ::price::ProductFilterStat* temp = product_filter_stat_;
  product_filter_stat_ = NULL;
  return temp;
}

// optional .price.PriceInfo base_price = 3;
inline bool DetailHotel::has_base_price() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void DetailHotel::set_has_base_price() {
  _has_bits_[0] |= 0x00000010u;
}
inline void DetailHotel::clear_has_base_price() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void DetailHotel::clear_base_price() {
  if (base_price_ != NULL) base_price_->::price::PriceInfo::Clear();
  clear_has_base_price();
}
inline const ::price::PriceInfo& DetailHotel::base_price() const {
  return base_price_ != NULL ? *base_price_ : *default_instance_->base_price_;
}
inline ::price::PriceInfo* DetailHotel::mutable_base_price() {
  set_has_base_price();
  if (base_price_ == NULL) base_price_ = new ::price::PriceInfo;
  return base_price_;
}
inline ::price::PriceInfo* DetailHotel::release_base_price() {
  clear_has_base_price();
  ::price::PriceInfo* temp = base_price_;
  base_price_ = NULL;
  return temp;
}

// repeated .price.DetailOta detail_ota_list = 11;
inline int DetailHotel::detail_ota_list_size() const {
  return detail_ota_list_.size();
}
inline void DetailHotel::clear_detail_ota_list() {
  detail_ota_list_.Clear();
}
inline const ::price::DetailOta& DetailHotel::detail_ota_list(int index) const {
  return detail_ota_list_.Get(index);
}
inline ::price::DetailOta* DetailHotel::mutable_detail_ota_list(int index) {
  return detail_ota_list_.Mutable(index);
}
inline ::price::DetailOta* DetailHotel::add_detail_ota_list() {
  return detail_ota_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::price::DetailOta >&
DetailHotel::detail_ota_list() const {
  return detail_ota_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::price::DetailOta >*
DetailHotel::mutable_detail_ota_list() {
  return &detail_ota_list_;
}

// repeated .price.Tag tag = 12;
inline int DetailHotel::tag_size() const {
  return tag_.size();
}
inline void DetailHotel::clear_tag() {
  tag_.Clear();
}
inline const ::price::Tag& DetailHotel::tag(int index) const {
  return tag_.Get(index);
}
inline ::price::Tag* DetailHotel::mutable_tag(int index) {
  return tag_.Mutable(index);
}
inline ::price::Tag* DetailHotel::add_tag() {
  return tag_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::price::Tag >&
DetailHotel::tag() const {
  return tag_;
}
inline ::google::protobuf::RepeatedPtrField< ::price::Tag >*
DetailHotel::mutable_tag() {
  return &tag_;
}

// -------------------------------------------------------------------

// ListOta

// optional int32 base_hotel_id = 1;
inline bool ListOta::has_base_hotel_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ListOta::set_has_base_hotel_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ListOta::clear_has_base_hotel_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ListOta::clear_base_hotel_id() {
  base_hotel_id_ = 0;
  clear_has_base_hotel_id();
}
inline ::google::protobuf::int32 ListOta::base_hotel_id() const {
  return base_hotel_id_;
}
inline void ListOta::set_base_hotel_id(::google::protobuf::int32 value) {
  set_has_base_hotel_id();
  base_hotel_id_ = value;
}

// optional int64 crawl_time = 2;
inline bool ListOta::has_crawl_time() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ListOta::set_has_crawl_time() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ListOta::clear_has_crawl_time() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ListOta::clear_crawl_time() {
  crawl_time_ = GOOGLE_LONGLONG(0);
  clear_has_crawl_time();
}
inline ::google::protobuf::int64 ListOta::crawl_time() const {
  return crawl_time_;
}
inline void ListOta::set_crawl_time(::google::protobuf::int64 value) {
  set_has_crawl_time();
  crawl_time_ = value;
}

// required int32 ota_id = 3;
inline bool ListOta::has_ota_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ListOta::set_has_ota_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ListOta::clear_has_ota_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ListOta::clear_ota_id() {
  ota_id_ = 0;
  clear_has_ota_id();
}
inline ::google::protobuf::int32 ListOta::ota_id() const {
  return ota_id_;
}
inline void ListOta::set_ota_id(::google::protobuf::int32 value) {
  set_has_ota_id();
  ota_id_ = value;
}

// optional .price.PriceInfo origin_price = 4;
inline bool ListOta::has_origin_price() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ListOta::set_has_origin_price() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ListOta::clear_has_origin_price() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ListOta::clear_origin_price() {
  if (origin_price_ != NULL) origin_price_->::price::PriceInfo::Clear();
  clear_has_origin_price();
}
inline const ::price::PriceInfo& ListOta::origin_price() const {
  return origin_price_ != NULL ? *origin_price_ : *default_instance_->origin_price_;
}
inline ::price::PriceInfo* ListOta::mutable_origin_price() {
  set_has_origin_price();
  if (origin_price_ == NULL) origin_price_ = new ::price::PriceInfo;
  return origin_price_;
}
inline ::price::PriceInfo* ListOta::release_origin_price() {
  clear_has_origin_price();
  ::price::PriceInfo* temp = origin_price_;
  origin_price_ = NULL;
  return temp;
}

// optional .price.PriceInfo sale_price = 5;
inline bool ListOta::has_sale_price() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ListOta::set_has_sale_price() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ListOta::clear_has_sale_price() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ListOta::clear_sale_price() {
  if (sale_price_ != NULL) sale_price_->::price::PriceInfo::Clear();
  clear_has_sale_price();
}
inline const ::price::PriceInfo& ListOta::sale_price() const {
  return sale_price_ != NULL ? *sale_price_ : *default_instance_->sale_price_;
}
inline ::price::PriceInfo* ListOta::mutable_sale_price() {
  set_has_sale_price();
  if (sale_price_ == NULL) sale_price_ = new ::price::PriceInfo;
  return sale_price_;
}
inline ::price::PriceInfo* ListOta::release_sale_price() {
  clear_has_sale_price();
  ::price::PriceInfo* temp = sale_price_;
  sale_price_ = NULL;
  return temp;
}

// repeated .price.PromotionInfo promotion_info = 6;
inline int ListOta::promotion_info_size() const {
  return promotion_info_.size();
}
inline void ListOta::clear_promotion_info() {
  promotion_info_.Clear();
}
inline const ::price::PromotionInfo& ListOta::promotion_info(int index) const {
  return promotion_info_.Get(index);
}
inline ::price::PromotionInfo* ListOta::mutable_promotion_info(int index) {
  return promotion_info_.Mutable(index);
}
inline ::price::PromotionInfo* ListOta::add_promotion_info() {
  return promotion_info_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::price::PromotionInfo >&
ListOta::promotion_info() const {
  return promotion_info_;
}
inline ::google::protobuf::RepeatedPtrField< ::price::PromotionInfo >*
ListOta::mutable_promotion_info() {
  return &promotion_info_;
}

// optional .price.PayType pay_type = 7 [default = PRE_PAY];
inline bool ListOta::has_pay_type() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ListOta::set_has_pay_type() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ListOta::clear_has_pay_type() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ListOta::clear_pay_type() {
  pay_type_ = 1;
  clear_has_pay_type();
}
inline price::PayType ListOta::pay_type() const {
  return static_cast< price::PayType >(pay_type_);
}
inline void ListOta::set_pay_type(price::PayType value) {
  GOOGLE_DCHECK(price::PayType_IsValid(value));
  set_has_pay_type();
  pay_type_ = value;
}

// -------------------------------------------------------------------

// ListHotel

// required int32 base_hotel_id = 1;
inline bool ListHotel::has_base_hotel_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ListHotel::set_has_base_hotel_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ListHotel::clear_has_base_hotel_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ListHotel::clear_base_hotel_id() {
  base_hotel_id_ = 0;
  clear_has_base_hotel_id();
}
inline ::google::protobuf::int32 ListHotel::base_hotel_id() const {
  return base_hotel_id_;
}
inline void ListHotel::set_base_hotel_id(::google::protobuf::int32 value) {
  set_has_base_hotel_id();
  base_hotel_id_ = value;
}

// optional int64 crawl_time = 2;
inline bool ListHotel::has_crawl_time() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ListHotel::set_has_crawl_time() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ListHotel::clear_has_crawl_time() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ListHotel::clear_crawl_time() {
  crawl_time_ = GOOGLE_LONGLONG(0);
  clear_has_crawl_time();
}
inline ::google::protobuf::int64 ListHotel::crawl_time() const {
  return crawl_time_;
}
inline void ListHotel::set_crawl_time(::google::protobuf::int64 value) {
  set_has_crawl_time();
  crawl_time_ = value;
}

// optional .price.BookingStatus booking_status = 4;
inline bool ListHotel::has_booking_status() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ListHotel::set_has_booking_status() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ListHotel::clear_has_booking_status() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ListHotel::clear_booking_status() {
  booking_status_ = 1;
  clear_has_booking_status();
}
inline price::BookingStatus ListHotel::booking_status() const {
  return static_cast< price::BookingStatus >(booking_status_);
}
inline void ListHotel::set_booking_status(price::BookingStatus value) {
  GOOGLE_DCHECK(price::BookingStatus_IsValid(value));
  set_has_booking_status();
  booking_status_ = value;
}

// repeated .price.PromotionInfo promotion_info = 5;
inline int ListHotel::promotion_info_size() const {
  return promotion_info_.size();
}
inline void ListHotel::clear_promotion_info() {
  promotion_info_.Clear();
}
inline const ::price::PromotionInfo& ListHotel::promotion_info(int index) const {
  return promotion_info_.Get(index);
}
inline ::price::PromotionInfo* ListHotel::mutable_promotion_info(int index) {
  return promotion_info_.Mutable(index);
}
inline ::price::PromotionInfo* ListHotel::add_promotion_info() {
  return promotion_info_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::price::PromotionInfo >&
ListHotel::promotion_info() const {
  return promotion_info_;
}
inline ::google::protobuf::RepeatedPtrField< ::price::PromotionInfo >*
ListHotel::mutable_promotion_info() {
  return &promotion_info_;
}

// repeated .price.ListOta list_ota_list = 6;
inline int ListHotel::list_ota_list_size() const {
  return list_ota_list_.size();
}
inline void ListHotel::clear_list_ota_list() {
  list_ota_list_.Clear();
}
inline const ::price::ListOta& ListHotel::list_ota_list(int index) const {
  return list_ota_list_.Get(index);
}
inline ::price::ListOta* ListHotel::mutable_list_ota_list(int index) {
  return list_ota_list_.Mutable(index);
}
inline ::price::ListOta* ListHotel::add_list_ota_list() {
  return list_ota_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::price::ListOta >&
ListHotel::list_ota_list() const {
  return list_ota_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::price::ListOta >*
ListHotel::mutable_list_ota_list() {
  return &list_ota_list_;
}

// optional bool mobile_only = 7 [default = false];
inline bool ListHotel::has_mobile_only() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ListHotel::set_has_mobile_only() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ListHotel::clear_has_mobile_only() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ListHotel::clear_mobile_only() {
  mobile_only_ = false;
  clear_has_mobile_only();
}
inline bool ListHotel::mobile_only() const {
  return mobile_only_;
}
inline void ListHotel::set_mobile_only(bool value) {
  set_has_mobile_only();
  mobile_only_ = value;
}

// repeated .price.Tag tag = 12;
inline int ListHotel::tag_size() const {
  return tag_.size();
}
inline void ListHotel::clear_tag() {
  tag_.Clear();
}
inline const ::price::Tag& ListHotel::tag(int index) const {
  return tag_.Get(index);
}
inline ::price::Tag* ListHotel::mutable_tag(int index) {
  return tag_.Mutable(index);
}
inline ::price::Tag* ListHotel::add_tag() {
  return tag_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::price::Tag >&
ListHotel::tag() const {
  return tag_;
}
inline ::google::protobuf::RepeatedPtrField< ::price::Tag >*
ListHotel::mutable_tag() {
  return &tag_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace price

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< price::RequestType>() {
  return price::RequestType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< price::HotelStatus>() {
  return price::HotelStatus_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< price::BookingStatus>() {
  return price::BookingStatus_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< price::PromotionType>() {
  return price::PromotionType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< price::TagType>() {
  return price::TagType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< price::PayType>() {
  return price::PayType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< price::ChargePriceMode>() {
  return price::ChargePriceMode_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< price::ChargePriceType>() {
  return price::ChargePriceType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_price_5ftypes_2eproto__INCLUDED
